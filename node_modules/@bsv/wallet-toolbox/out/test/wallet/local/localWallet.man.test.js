"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.confirmSpendableOutputs = confirmSpendableOutputs;
const sdk_1 = require("@bsv/sdk");
const src_1 = require("../../../src");
const TestUtilsWalletStorage_1 = require("../../utils/TestUtilsWalletStorage");
const sdk_2 = require("../../../src/sdk");
const setActiveClient = true;
const useMySQLConnectionForClient = true;
describe('localWallet tests', () => {
    jest.setTimeout(99999999);
    test('00', () => { });
    if (TestUtilsWalletStorage_1._tu.noTestEnv('test'))
        return;
    if (TestUtilsWalletStorage_1._tu.noTestEnv('main'))
        return;
    test('0 monitor runOnce', async () => {
        const setup = await createSetup('test');
        await setup.monitor.runOnce();
        await setup.wallet.destroy();
    });
    test('1 recover 1 sat outputs', async () => {
        const setup = await createSetup('test');
        await recoverOneSatTestOutputs(setup);
        await setup.wallet.destroy();
    });
    test('2 create 1 sat delayed', async () => {
        const setup = await createSetup('test');
        const car = await createOneSatTestOutput(setup, {}, 1);
        //await trackReqByTxid(setup, car.txid!)
        await setup.wallet.destroy();
    });
    test('2a create 1 sat immediate', async () => {
        const setup = await createSetup('test');
        const car = await createOneSatTestOutput(setup, { acceptDelayedBroadcast: false }, 1);
        // await trackReqByTxid(setup, car.txid!)
        await setup.wallet.destroy();
    });
    test('2b create 2 nosend and sendWith', async () => {
        const setup = await createSetup('test');
        const car = await createOneSatTestOutput(setup, { noSend: true }, 2);
        //await trackReqByTxid(setup, car.txid!)
        await setup.wallet.destroy();
    });
    test('3 return active to cloud client', async () => {
        const setup = await createSetup('test');
        const localBalance = await setup.wallet.balance();
        const log = await setup.storage.setActive(setup.clientStorageIdentityKey);
        console.log(log);
        console.log(`ACTIVE STORAGE: ${setup.storage.getActiveStoreName()}`);
        const clientBalance = await setup.wallet.balance();
        expect(localBalance.total).toBe(clientBalance.total);
        await setup.wallet.destroy();
    });
    test('4 review change utxos', async () => {
        const setup = await createSetup('test');
        const lor = await setup.wallet.listOutputs({
            basket: sdk_2.specOpInvalidChange,
            limit: 1000
        });
        if (lor.totalOutputs > 0) {
            debugger;
            const lor = await setup.wallet.listOutputs({
                basket: sdk_2.specOpInvalidChange,
                tags: ['release']
            });
        }
        /*
        const storage = setup.activeStorage
        const services = setup.services
        const { invalidSpendableOutputs: notUtxos } = await confirmSpendableOutputs(storage, services)
        const outputsToUpdate = notUtxos.map(o => ({ id: o.outputId, satoshis: o.satoshis }))
        const total: number = outputsToUpdate.reduce((t, o) => t + o.satoshis, 0)
        debugger
        // *** About set spendable = false for outputs ***
        for (const o of outputsToUpdate) {
          await storage.updateOutput(o.id, { spendable: false })
        }
        */
        await setup.wallet.destroy();
    });
    test('5 review synchunk', async () => {
        const setup = await createSetup('test');
        const identityKey = setup.identityKey;
        const reader = setup.activeStorage;
        const readerSettings = reader.getSettings();
        const writer = setup.storage._backups[0].storage;
        const writerSettings = writer.getSettings();
        const ss = await src_1.EntitySyncState.fromStorage(writer, identityKey, readerSettings);
        const args = ss.makeRequestSyncChunkArgs(identityKey, writerSettings.storageIdentityKey);
        const chunk = await reader.getSyncChunk(args);
        await setup.wallet.destroy();
    });
    test('6 backup', async () => {
        const setup = await createSetup('test');
        const log = await setup.storage.updateBackups();
        console.log(log);
        await setup.wallet.destroy();
    });
});
async function createSetup(chain) {
    const env = TestUtilsWalletStorage_1._tu.getEnv(chain);
    if (!env.testIdentityKey)
        throw new src_1.sdk.WERR_INVALID_PARAMETER('env.testIdentityKey', 'valid');
    if (!env.testFilePath)
        throw new src_1.sdk.WERR_INVALID_PARAMETER('env.testFilePath', 'valid');
    const setup = await TestUtilsWalletStorage_1._tu.createTestWallet({
        chain,
        rootKeyHex: env.devKeys[env.testIdentityKey],
        filePath: env.testFilePath,
        setActiveClient,
        addLocalBackup: false,
        useMySQLConnectionForClient
    });
    console.log(`ACTIVE STORAGE: ${setup.storage.getActiveStoreName()}`);
    return setup;
}
async function createOneSatTestOutput(setup, options = {}, howMany = 1) {
    if (howMany < 1)
        throw new src_1.sdk.WERR_INVALID_PARAMETER('howMany', 'at least 1');
    let car = {};
    let noSendChange = undefined;
    let txids = [];
    let vargs;
    for (let i = 0; i < howMany; i++) {
        const args = {
            outputs: [
                {
                    lockingScript: new sdk_1.P2PKH().lock(sdk_1.PublicKey.fromString(setup.identityKey).toAddress()).toHex(),
                    satoshis: 1,
                    outputDescription: 'test output',
                    customInstructions: JSON.stringify({
                        type: 'P2PKH',
                        key: 'identity'
                    }),
                    basket: 'test-output'
                }
            ],
            description: 'create test output',
            options: {
                ...options,
                noSendChange
            }
        };
        vargs = (0, sdk_2.validateCreateActionArgs)(args);
        car = await setup.wallet.createAction(args);
        expect(car.txid);
        txids.push(car.txid);
        noSendChange = car.noSendChange;
        const req = await src_1.EntityProvenTxReq.fromStorageTxid(setup.activeStorage, car.txid);
        expect(req !== undefined && req.history.notes !== undefined);
        if (req && req.history.notes) {
            if (vargs.isNoSend) {
                expect(req.status === 'nosend').toBe(true);
                expect(req.history.notes.length).toBe(1);
                const n = req.history.notes[0];
                expect(n.what === 'status' && n.status_now === 'nosend').toBe(true);
            }
            else {
                expect(req.status === 'unsent').toBe(true);
                expect(req.history.notes.length).toBe(1);
                const n = req.history.notes[0];
                expect(n.what === 'status' && n.status_now === 'unsent').toBe(true);
            }
        }
    }
    if (vargs.isNoSend) {
        // Create final sending transaction
        const args = {
            description: 'send batch',
            options: {
                ...options,
                sendWith: txids
            }
        };
        vargs = (0, sdk_2.validateCreateActionArgs)(args);
        car = await setup.wallet.createAction(args);
    }
    return car;
}
async function recoverOneSatTestOutputs(setup) {
    const outputs = await setup.wallet.listOutputs({
        basket: 'test-output',
        include: 'entire transactions',
        limit: 1000
    });
    if (outputs.outputs.length > 8) {
        const args = {
            inputBEEF: outputs.BEEF,
            inputs: [],
            description: 'recover test output'
        };
        const p2pkh = new sdk_1.P2PKH();
        for (const o of outputs.outputs) {
            args.inputs.push({
                unlockingScriptLength: 108,
                outpoint: o.outpoint,
                inputDescription: 'recovered test output'
            });
        }
        const car = await setup.wallet.createAction(args);
        expect(car.signableTransaction);
        const st = car.signableTransaction;
        const beef = sdk_1.Beef.fromBinary(st.tx);
        const tx = beef.findAtomicTransaction(beef.txs.slice(-1)[0].txid);
        const signArgs = {
            reference: st.reference,
            spends: {} //  0: { unlockingScript } },
        };
        for (let i = 0; i < outputs.outputs.length; i++) {
            const o = outputs.outputs[i];
            const unlock = p2pkh.unlock(setup.keyDeriver.rootKey, 'all', false);
            const unlockingScript = (await unlock.sign(tx, i)).toHex();
            signArgs.spends[i] = { unlockingScript };
        }
        const sar = await setup.wallet.signAction(signArgs);
        expect(sar.txid);
    }
}
async function trackReqByTxid(setup, txid) {
    var _a;
    const req = await src_1.EntityProvenTxReq.fromStorageTxid(setup.activeStorage, txid);
    expect(req !== undefined && req.history.notes !== undefined);
    if (!req || !req.history.notes)
        throw new src_1.sdk.WERR_INTERNAL();
    let newBlocks = 0;
    let lastHeight;
    for (; req.status !== 'completed';) {
        let height = (_a = setup.monitor.lastNewHeader) === null || _a === void 0 ? void 0 : _a.height;
        if (req.status === 'unsent') {
            // send it...
        }
        if (req.status === 'sending') {
            // send it...
        }
        if (req.status === 'unmined') {
            if (height && lastHeight) {
                if (height === lastHeight) {
                    await (0, src_1.wait)(1000 * 60);
                }
                else {
                    newBlocks++;
                    expect(newBlocks < 5);
                }
            }
        }
        await setup.monitor.runOnce();
        await req.refreshFromStorage(setup.activeStorage);
        lastHeight = height;
    }
}
async function confirmSpendableOutputs(storage, services, identityKey) {
    var _a;
    const invalidSpendableOutputs = [];
    const partial = {};
    if (identityKey)
        partial.identityKey = identityKey;
    const users = await storage.findUsers({ partial });
    for (const { userId } of users) {
        const defaultBasket = (0, src_1.verifyOne)(await storage.findOutputBaskets({ partial: { userId, name: 'default' } }));
        const where = {
            userId,
            basketId: defaultBasket.basketId,
            spendable: true
        };
        const outputs = await storage.findOutputs({ partial: where });
        for (let i = outputs.length - 1; i >= 0; i--) {
            const o = outputs[i];
            const oid = (0, src_1.verifyId)(o.outputId);
            if (o.spendable) {
                let ok = false;
                if (o.lockingScript && o.lockingScript.length > 0) {
                    const r = await services.getUtxoStatus((0, src_1.asString)(o.lockingScript), 'script');
                    if (r.status === 'success' && r.isUtxo && ((_a = r.details) === null || _a === void 0 ? void 0 : _a.length) > 0) {
                        const tx = await storage.findTransactionById(o.transactionId);
                        if (tx &&
                            tx.txid &&
                            r.details.some(d => d.txid === tx.txid && d.satoshis === o.satoshis && d.index === o.vout)) {
                            ok = true;
                        }
                    }
                }
                if (!ok) {
                    invalidSpendableOutputs.push(o);
                }
            }
        }
    }
    return { invalidSpendableOutputs };
}
//# sourceMappingURL=localWallet.man.test.js.map