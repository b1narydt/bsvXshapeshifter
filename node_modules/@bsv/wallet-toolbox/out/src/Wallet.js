"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Wallet = void 0;
const sdk_1 = require("@bsv/sdk");
const index_client_1 = require("./index.client");
const acquireDirectCertificate_1 = require("./signer/methods/acquireDirectCertificate");
const proveCertificate_1 = require("./signer/methods/proveCertificate");
const createAction_1 = require("./signer/methods/createAction");
const signAction_1 = require("./signer/methods/signAction");
const internalizeAction_1 = require("./signer/methods/internalizeAction");
const WalletSettingsManager_1 = require("./WalletSettingsManager");
const identityUtils_1 = require("./utility/identityUtils");
const generateChange_1 = require("./storage/methods/generateChange");
function isWalletSigner(args) {
    return args['isWalletSigner'];
}
class Wallet {
    constructor(argsOrSigner, services, monitor, privilegedKeyManager) {
        /**
         * If true, signableTransactions will include sourceTransaction for each input,
         * including those that do not require signature and those that were also contained
         * in the inputBEEF.
         */
        this.includeAllSourceTransactions = true;
        /**
         * If true, beefs returned to the user may contain txidOnly transactions.
         */
        this.returnTxidOnly = false;
        /**
         * For repeatability testing, set to an array of random numbers from [0..1).
         */
        this.randomVals = undefined;
        const args = !isWalletSigner(argsOrSigner)
            ? argsOrSigner
            : {
                chain: argsOrSigner.chain,
                keyDeriver: argsOrSigner.keyDeriver,
                storage: argsOrSigner.storage,
                services,
                monitor,
                privilegedKeyManager
            };
        if (args.storage._authId.identityKey != args.keyDeriver.identityKey)
            throw new index_client_1.sdk.WERR_INVALID_PARAMETER('storage', `authenticated as the same identityKey (${args.storage._authId.identityKey}) as the keyDeriver (${args.keyDeriver.identityKey}).`);
        this.settingsManager = args.settingsManager || new WalletSettingsManager_1.WalletSettingsManager(this);
        this.chain = args.chain;
        this.lookupResolver =
            args.lookupResolver ||
                new sdk_1.LookupResolver({
                    networkPreset: (0, index_client_1.toWalletNetwork)(this.chain)
                });
        this.keyDeriver = args.keyDeriver;
        this.storage = args.storage;
        this.proto = new sdk_1.ProtoWallet(args.keyDeriver);
        this.services = args.services;
        this.monitor = args.monitor;
        this.privilegedKeyManager = args.privilegedKeyManager;
        this.identityKey = this.keyDeriver.identityKey;
        this.pendingSignActions = {};
        this.userParty = `user ${this.getClientChangeKeyPair().publicKey}`;
        this.beef = new sdk_1.BeefParty([this.userParty]);
        this.trustSelf = 'known';
        if (this.services) {
            this.storage.setServices(this.services);
        }
    }
    async destroy() {
        await this.storage.destroy();
        if (this.privilegedKeyManager)
            await this.privilegedKeyManager.destroyKey();
    }
    getClientChangeKeyPair() {
        const kp = {
            privateKey: this.keyDeriver.rootKey.toString(),
            publicKey: this.keyDeriver.rootKey.toPublicKey().toString()
        };
        return kp;
    }
    async getIdentityKey() {
        return (await this.getPublicKey({ identityKey: true })).publicKey;
    }
    getPublicKey(args, originator) {
        if (args.privileged) {
            if (!this.privilegedKeyManager) {
                throw new Error('Privileged operations require the Wallet to be configured with a privileged key manager.');
            }
            return this.privilegedKeyManager.getPublicKey(args);
        }
        return this.proto.getPublicKey(args);
    }
    revealCounterpartyKeyLinkage(args, originator) {
        if (args.privileged) {
            if (!this.privilegedKeyManager) {
                throw new Error('Privileged operations require the Wallet to be configured with a privileged key manager.');
            }
            return this.privilegedKeyManager.revealCounterpartyKeyLinkage(args);
        }
        return this.proto.revealCounterpartyKeyLinkage(args);
    }
    revealSpecificKeyLinkage(args, originator) {
        if (args.privileged) {
            if (!this.privilegedKeyManager) {
                throw new Error('Privileged operations require the Wallet to be configured with a privileged key manager.');
            }
            return this.privilegedKeyManager.revealSpecificKeyLinkage(args);
        }
        return this.proto.revealSpecificKeyLinkage(args);
    }
    encrypt(args, originator) {
        if (args.privileged) {
            if (!this.privilegedKeyManager) {
                throw new Error('Privileged operations require the Wallet to be configured with a privileged key manager.');
            }
            return this.privilegedKeyManager.encrypt(args);
        }
        return this.proto.encrypt(args);
    }
    decrypt(args, originator) {
        if (args.privileged) {
            if (!this.privilegedKeyManager) {
                throw new Error('Privileged operations require the Wallet to be configured with a privileged key manager.');
            }
            return this.privilegedKeyManager.decrypt(args);
        }
        return this.proto.decrypt(args);
    }
    createHmac(args, originator) {
        if (args.privileged) {
            if (!this.privilegedKeyManager) {
                throw new Error('Privileged operations require the Wallet to be configured with a privileged key manager.');
            }
            return this.privilegedKeyManager.createHmac(args);
        }
        return this.proto.createHmac(args);
    }
    verifyHmac(args, originator) {
        if (args.privileged) {
            if (!this.privilegedKeyManager) {
                throw new Error('Privileged operations require the Wallet to be configured with a privileged key manager.');
            }
            return this.privilegedKeyManager.verifyHmac(args);
        }
        return this.proto.verifyHmac(args);
    }
    createSignature(args, originator) {
        if (args.privileged) {
            if (!this.privilegedKeyManager) {
                throw new Error('Privileged operations require the Wallet to be configured with a privileged key manager.');
            }
            return this.privilegedKeyManager.createSignature(args);
        }
        return this.proto.createSignature(args);
    }
    verifySignature(args, originator) {
        if (args.privileged) {
            if (!this.privilegedKeyManager) {
                throw new Error('Privileged operations require the Wallet to be configured with a privileged key manager.');
            }
            return this.privilegedKeyManager.verifySignature(args);
        }
        return this.proto.verifySignature(args);
    }
    getServices() {
        if (!this.services)
            throw new index_client_1.sdk.WERR_INVALID_PARAMETER('services', 'valid in constructor arguments to be retreived here.');
        return this.services;
    }
    /**
     * @returns the full list of txids whose validity this wallet claims to know.
     *
     * @param newKnownTxids Optional. Additional new txids known to be valid by the caller to be merged.
     */
    getKnownTxids(newKnownTxids) {
        if (newKnownTxids) {
            for (const txid of newKnownTxids)
                this.beef.mergeTxidOnly(txid);
        }
        const r = this.beef.sortTxs();
        const knownTxids = r.valid;
        return knownTxids;
    }
    getStorageIdentity() {
        const s = this.storage.getSettings();
        return {
            storageIdentityKey: s.storageIdentityKey,
            storageName: s.storageName
        };
    }
    validateAuthAndArgs(args, validate) {
        const vargs = validate(args);
        const auth = { identityKey: this.identityKey };
        return { vargs, auth };
    }
    //////////////////
    // List Methods
    //////////////////
    async listActions(args, originator) {
        index_client_1.sdk.validateOriginator(originator);
        const { vargs } = this.validateAuthAndArgs(args, index_client_1.sdk.validateListActionsArgs);
        const r = await this.storage.listActions(vargs);
        return r;
    }
    get storageParty() {
        return `storage ${this.getStorageIdentity().storageIdentityKey}`;
    }
    async listOutputs(args, originator) {
        index_client_1.sdk.validateOriginator(originator);
        const { vargs } = this.validateAuthAndArgs(args, index_client_1.sdk.validateListOutputsArgs);
        vargs.knownTxids = this.getKnownTxids();
        const r = await this.storage.listOutputs(vargs);
        if (r.BEEF) {
            this.beef.mergeBeefFromParty(this.storageParty, r.BEEF);
            r.BEEF = this.verifyReturnedTxidOnlyBEEF(r.BEEF);
        }
        return r;
    }
    async listCertificates(args, originator) {
        index_client_1.sdk.validateOriginator(originator);
        const { vargs } = this.validateAuthAndArgs(args, index_client_1.sdk.validateListCertificatesArgs);
        const r = await this.storage.listCertificates(vargs);
        return r;
    }
    //////////////////
    // Certificates
    //////////////////
    async acquireCertificate(args, originator) {
        index_client_1.sdk.validateOriginator(originator);
        if (args.acquisitionProtocol === 'direct') {
            const { auth, vargs } = this.validateAuthAndArgs(args, index_client_1.sdk.validateAcquireDirectCertificateArgs);
            vargs.subject = (await this.getPublicKey({
                identityKey: true,
                privileged: args.privileged,
                privilegedReason: args.privilegedReason
            })).publicKey;
            try {
                // Confirm that the information received adds up to a usable certificate...
                // TODO: Clean up MasterCertificate to support decrypt on instance
                const cert = new sdk_1.MasterCertificate(vargs.type, vargs.serialNumber, vargs.subject, vargs.certifier, vargs.revocationOutpoint, vargs.fields, vargs.keyringForSubject, vargs.signature);
                await cert.verify();
                // Verify certificate details
                await sdk_1.MasterCertificate.decryptFields(this, vargs.keyringForSubject, vargs.fields, vargs.certifier, vargs.privileged, vargs.privilegedReason);
            }
            catch (eu) {
                const e = index_client_1.sdk.WalletError.fromUnknown(eu);
                throw new index_client_1.sdk.WERR_INVALID_PARAMETER('args', `valid encrypted and signed certificate and keyring from revealer. ${e.name}: ${e.message}`);
            }
            const r = await (0, acquireDirectCertificate_1.acquireDirectCertificate)(this, auth, vargs);
            return r;
        }
        if (args.acquisitionProtocol === 'issuance') {
            const { auth, vargs } = this.validateAuthAndArgs(args, index_client_1.sdk.validateAcquireIssuanceCertificateArgs);
            // Create a random nonce that the server can verify
            const clientNonce = await (0, sdk_1.createNonce)(this, vargs.certifier);
            // TODO: Consider adding support to request certificates from a certifier before acquiring a certificate.
            const authClient = new sdk_1.AuthFetch(this);
            // Create a certificate master keyring
            // The certifier is able to decrypt these fields as they are the counterparty
            const { certificateFields, masterKeyring } = await sdk_1.MasterCertificate.createCertificateFields(this, vargs.certifier, vargs.fields);
            // Make a Certificate Signing Request (CSR) to the certifier
            const response = await authClient.fetch(`${vargs.certifierUrl}/signCertificate`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    clientNonce,
                    type: vargs.type,
                    fields: certificateFields,
                    masterKeyring
                })
            });
            if (response.headers.get('x-bsv-auth-identity-key') !== vargs.certifier) {
                throw new Error(`Invalid certifier! Expected: ${vargs.certifier}, Received: ${response.headers.get('x-bsv-auth-identity-key')}`);
            }
            const { certificate, serverNonce } = await response.json();
            // Validate the server response
            if (!certificate) {
                throw new Error('No certificate received from certifier!');
            }
            if (!serverNonce) {
                throw new Error('No serverNonce received from certifier!');
            }
            const signedCertificate = new sdk_1.Certificate(certificate.type, certificate.serialNumber, certificate.subject, certificate.certifier, certificate.revocationOutpoint, certificate.fields, certificate.signature);
            // Validate server nonce
            await (0, sdk_1.verifyNonce)(serverNonce, this, vargs.certifier);
            // Verify the server included our nonce
            const { valid } = await this.verifyHmac({
                hmac: sdk_1.Utils.toArray(signedCertificate.serialNumber, 'base64'),
                data: sdk_1.Utils.toArray(clientNonce + serverNonce, 'base64'),
                protocolID: [2, 'certificate issuance'],
                keyID: serverNonce + clientNonce,
                counterparty: vargs.certifier
            });
            if (!valid)
                throw new Error('Invalid serialNumber');
            // Validate the certificate received
            if (signedCertificate.type !== vargs.type) {
                throw new Error(`Invalid certificate type! Expected: ${vargs.type}, Received: ${signedCertificate.type}`);
            }
            if (signedCertificate.subject !== this.identityKey) {
                throw new Error(`Invalid certificate subject! Expected: ${this.identityKey}, Received: ${signedCertificate.subject}`);
            }
            if (signedCertificate.certifier !== vargs.certifier) {
                throw new Error(`Invalid certifier! Expected: ${vargs.certifier}, Received: ${signedCertificate.certifier}`);
            }
            if (!signedCertificate.revocationOutpoint) {
                throw new Error(`Invalid revocationOutpoint!`);
            }
            if (Object.keys(signedCertificate.fields).length !== Object.keys(certificateFields).length) {
                throw new Error(`Fields mismatch! Objects have different numbers of keys.`);
            }
            for (const field of Object.keys(certificateFields)) {
                if (!(field in signedCertificate.fields)) {
                    throw new Error(`Missing field: ${field} in certificate.fields`);
                }
                if (signedCertificate.fields[field] !== certificateFields[field]) {
                    throw new Error(`Invalid field! Expected: ${certificateFields[field]}, Received: ${signedCertificate.fields[field]}`);
                }
            }
            await signedCertificate.verify();
            // Test decryption works
            await sdk_1.MasterCertificate.decryptFields(this, masterKeyring, certificate.fields, vargs.certifier);
            // Store the newly issued certificate
            return await (0, acquireDirectCertificate_1.acquireDirectCertificate)(this, auth, {
                ...certificate,
                keyringRevealer: 'certifier',
                keyringForSubject: masterKeyring,
                privileged: vargs.privileged
            });
        }
        throw new index_client_1.sdk.WERR_INVALID_PARAMETER('acquisitionProtocol', `valid.${args.acquisitionProtocol} is unrecognized.`);
    }
    async relinquishCertificate(args, originator) {
        index_client_1.sdk.validateOriginator(originator);
        this.validateAuthAndArgs(args, index_client_1.sdk.validateRelinquishCertificateArgs);
        const r = await this.storage.relinquishCertificate(args);
        return { relinquished: true };
    }
    async proveCertificate(args, originator) {
        originator = index_client_1.sdk.validateOriginator(originator);
        const { auth, vargs } = this.validateAuthAndArgs(args, index_client_1.sdk.validateProveCertificateArgs);
        const r = await (0, proveCertificate_1.proveCertificate)(this, auth, vargs);
        return r;
    }
    async discoverByIdentityKey(args, originator) {
        index_client_1.sdk.validateOriginator(originator);
        this.validateAuthAndArgs(args, index_client_1.sdk.validateDiscoverByIdentityKeyArgs);
        const trustSettings = (await this.settingsManager.get()).trustSettings;
        const results = await (0, identityUtils_1.queryOverlay)({
            identityKey: args.identityKey,
            certifiers: trustSettings.trustedCertifiers.map(certifier => certifier.identityKey)
        }, this.lookupResolver);
        if (!results) {
            return {
                totalCertificates: 0,
                certificates: []
            };
        }
        return (0, identityUtils_1.transformVerifiableCertificatesWithTrust)(trustSettings, results);
    }
    async discoverByAttributes(args, originator) {
        index_client_1.sdk.validateOriginator(originator);
        this.validateAuthAndArgs(args, index_client_1.sdk.validateDiscoverByAttributesArgs);
        const trustSettings = (await this.settingsManager.get()).trustSettings;
        const results = await (0, identityUtils_1.queryOverlay)({
            attributes: args.attributes,
            certifiers: trustSettings.trustedCertifiers.map(certifier => certifier.identityKey)
        }, this.lookupResolver);
        if (!results) {
            return {
                totalCertificates: 0,
                certificates: []
            };
        }
        return (0, identityUtils_1.transformVerifiableCertificatesWithTrust)(trustSettings, results);
    }
    verifyReturnedTxidOnly(beef) {
        if (this.returnTxidOnly)
            return beef;
        const onlyTxids = beef.txs.filter(btx => btx.isTxidOnly).map(btx => btx.txid);
        for (const txid of onlyTxids) {
            const btx = beef.findTxid(txid);
            const tx = this.beef.findAtomicTransaction(txid);
            if (!tx)
                throw new index_client_1.sdk.WERR_INTERNAL();
            beef.mergeTransaction(tx);
        }
        for (const btx of beef.txs) {
            if (btx.isTxidOnly)
                throw new index_client_1.sdk.WERR_INTERNAL();
        }
        return beef;
    }
    verifyReturnedTxidOnlyAtomicBEEF(beef) {
        if (this.returnTxidOnly)
            return beef;
        const b = sdk_1.Beef.fromBinary(beef);
        if (!b.atomicTxid)
            throw new index_client_1.sdk.WERR_INTERNAL();
        return this.verifyReturnedTxidOnly(b).toBinaryAtomic(b.atomicTxid);
    }
    verifyReturnedTxidOnlyBEEF(beef) {
        if (this.returnTxidOnly)
            return beef;
        const b = sdk_1.Beef.fromBinary(beef);
        return this.verifyReturnedTxidOnly(b).toBinary();
    }
    //////////////////
    // Actions
    //////////////////
    async createAction(args, originator) {
        var _a;
        index_client_1.sdk.validateOriginator(originator);
        if (!args.options)
            args.options = {};
        (_a = args.options).trustSelf || (_a.trustSelf = this.trustSelf);
        args.options.knownTxids = this.getKnownTxids(args.options.knownTxids);
        const { auth, vargs } = this.validateAuthAndArgs(args, index_client_1.sdk.validateCreateActionArgs);
        vargs.includeAllSourceTransactions = this.includeAllSourceTransactions;
        if (this.randomVals && this.randomVals.length > 1) {
            vargs.randomVals = [...this.randomVals];
        }
        const r = await (0, createAction_1.createAction)(this, auth, vargs);
        if (r.tx) {
            this.beef.mergeBeefFromParty(this.storageParty, r.tx);
        }
        if (r.tx)
            r.tx = this.verifyReturnedTxidOnlyAtomicBEEF(r.tx);
        if (!vargs.options.acceptDelayedBroadcast &&
            r.sendWithResults &&
            r.sendWithResults.length === 1 &&
            r.sendWithResults[0].status === 'failed')
            throw new index_client_1.sdk.WERR_BROADCAST_UNAVAILABLE();
        return r;
    }
    async signAction(args, originator) {
        index_client_1.sdk.validateOriginator(originator);
        const { auth, vargs } = this.validateAuthAndArgs(args, index_client_1.sdk.validateSignActionArgs);
        const r = await (0, signAction_1.signAction)(this, auth, vargs);
        if (!vargs.options.acceptDelayedBroadcast &&
            r.sendWithResults &&
            r.sendWithResults.length === 1 &&
            r.sendWithResults[0].status === 'failed')
            throw new index_client_1.sdk.WERR_BROADCAST_UNAVAILABLE();
        if (r.tx)
            r.tx = this.verifyReturnedTxidOnlyAtomicBEEF(r.tx);
        return r;
    }
    async abortAction(args, originator) {
        index_client_1.sdk.validateOriginator(originator);
        const { auth } = this.validateAuthAndArgs(args, index_client_1.sdk.validateAbortActionArgs);
        const r = await this.storage.abortAction(args);
        return r;
    }
    async internalizeAction(args, originator) {
        index_client_1.sdk.validateOriginator(originator);
        const { auth, vargs } = this.validateAuthAndArgs(args, index_client_1.sdk.validateInternalizeActionArgs);
        const r = await (0, internalizeAction_1.internalizeAction)(this, auth, args);
        return r;
    }
    async relinquishOutput(args, originator) {
        index_client_1.sdk.validateOriginator(originator);
        const { vargs } = this.validateAuthAndArgs(args, index_client_1.sdk.validateRelinquishOutputArgs);
        const r = await this.storage.relinquishOutput(args);
        return { relinquished: true };
    }
    async isAuthenticated(args, originator) {
        index_client_1.sdk.validateOriginator(originator);
        const r = {
            authenticated: true
        };
        return r;
    }
    async waitForAuthentication(args, originator) {
        index_client_1.sdk.validateOriginator(originator);
        return { authenticated: true };
    }
    async getHeight(args, originator) {
        index_client_1.sdk.validateOriginator(originator);
        const height = await this.getServices().getHeight();
        return { height };
    }
    async getHeaderForHeight(args, originator) {
        index_client_1.sdk.validateOriginator(originator);
        const serializedHeader = await this.getServices().getHeaderForHeight(args.height);
        return { header: sdk_1.Utils.toHex(serializedHeader) };
    }
    async getNetwork(args, originator) {
        index_client_1.sdk.validateOriginator(originator);
        return { network: (0, index_client_1.toWalletNetwork)(this.chain) };
    }
    async getVersion(args, originator) {
        index_client_1.sdk.validateOriginator(originator);
        return { version: 'wallet-brc100-1.0.0' };
    }
    /**
     * Transfer all possible satoshis held by this wallet to `toWallet`.
     *
     * @param toWallet wallet which will receive this wallet's satoshis.
     */
    async sweepTo(toWallet) {
        const derivationPrefix = (0, index_client_1.randomBytesBase64)(8);
        const derivationSuffix = (0, index_client_1.randomBytesBase64)(8);
        const keyDeriver = this.keyDeriver;
        const t = new index_client_1.ScriptTemplateBRC29({
            derivationPrefix,
            derivationSuffix,
            keyDeriver
        });
        const label = 'sweep';
        const satoshis = generateChange_1.maxPossibleSatoshis;
        const car = await this.createAction({
            outputs: [
                {
                    lockingScript: t.lock(keyDeriver.rootKey.toString(), toWallet.identityKey).toHex(),
                    satoshis,
                    outputDescription: label,
                    tags: ['relinquish'],
                    customInstructions: JSON.stringify({
                        derivationPrefix,
                        derivationSuffix,
                        type: 'BRC29'
                    })
                }
            ],
            options: {
                randomizeOutputs: false,
                acceptDelayedBroadcast: false
            },
            labels: [label],
            description: label
        });
        const iar = await toWallet.internalizeAction({
            tx: car.tx,
            outputs: [
                {
                    outputIndex: 0,
                    protocol: 'wallet payment',
                    paymentRemittance: {
                        derivationPrefix,
                        derivationSuffix,
                        senderIdentityKey: this.identityKey
                    }
                }
            ],
            description: label,
            labels: [label]
        });
    }
    /**
     * Uses `listOutputs` to iterate through all spendable outputs in the 'default' (change) basket.
     *
     * Outputs in the 'default' basket are managed by the wallet and MUST NOT USED AS UNMANAGED INPUTS.
     *
     * @param {string} basket - Optional. Defaults to 'default', the wallet change basket.
     * @returns { total: number, utxos: { satoshis: number, outpoint: string }[] }
     */
    async balance(basket = 'default') {
        const r = { total: 0, utxos: [] };
        let offset = 0;
        for (;;) {
            const change = await this.listOutputs({
                basket,
                limit: 1000,
                offset
            });
            if (change.totalOutputs === 0)
                break;
            for (const o of change.outputs) {
                r.total += o.satoshis;
                r.utxos.push({ satoshis: o.satoshis, outpoint: o.outpoint });
            }
            offset += change.outputs.length;
        }
        return r;
    }
}
exports.Wallet = Wallet;
//# sourceMappingURL=Wallet.js.map