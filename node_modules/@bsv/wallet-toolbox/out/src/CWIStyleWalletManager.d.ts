import { AbortActionArgs, AbortActionResult, AcquireCertificateArgs, AcquireCertificateResult, AuthenticatedResult, CreateActionArgs, CreateActionResult, CreateHmacArgs, CreateHmacResult, CreateSignatureArgs, CreateSignatureResult, DiscoverByAttributesArgs, DiscoverByIdentityKeyArgs, DiscoverCertificatesResult, GetHeaderArgs, GetHeaderResult, GetHeightResult, GetNetworkResult, GetPublicKeyArgs, GetPublicKeyResult, GetVersionResult, InternalizeActionArgs, InternalizeActionResult, ListActionsArgs, ListActionsResult, ListCertificatesArgs, ListCertificatesResult, ListOutputsArgs, ListOutputsResult, OriginatorDomainNameStringUnder250Bytes, ProveCertificateArgs, ProveCertificateResult, RelinquishCertificateArgs, RelinquishCertificateResult, RelinquishOutputArgs, RelinquishOutputResult, RevealCounterpartyKeyLinkageArgs, RevealCounterpartyKeyLinkageResult, RevealSpecificKeyLinkageArgs, RevealSpecificKeyLinkageResult, SignActionArgs, SignActionResult, VerifyHmacArgs, VerifyHmacResult, VerifySignatureArgs, VerifySignatureResult, WalletDecryptArgs, WalletDecryptResult, WalletEncryptArgs, WalletEncryptResult, WalletInterface, OutpointString, LookupResolver, SHIPBroadcaster } from '@bsv/sdk';
import { PrivilegedKeyManager } from './sdk/PrivilegedKeyManager';
/**
 * Number of rounds used in PBKDF2 for deriving password keys.
 */
export declare const PBKDF2_NUM_ROUNDS = 7777;
/**
 * Describes the structure of a User Management Protocol (UMP) token.
 */
export interface UMPToken {
    /**
     * Primary key encrypted by the XOR of the password and presentation keys.
     */
    passwordPresentationPrimary: number[];
    /**
     * Primary key encrypted by the XOR of the password and recovery keys.
     */
    passwordRecoveryPrimary: number[];
    /**
     * Primary key encrypted by the XOR of the presentation and recovery keys.
     */
    presentationRecoveryPrimary: number[];
    /**
     * Privileged key encrypted by the XOR of the password and primary keys.
     */
    passwordPrimaryPrivileged: number[];
    /**
     * Privileged key encrypted by the XOR of the presentation and recovery keys.
     */
    presentationRecoveryPrivileged: number[];
    /**
     * Hash of the presentation key.
     */
    presentationHash: number[];
    /**
     * PBKDF2 salt used in conjunction with the password to derive the password key.
     */
    passwordSalt: number[];
    /**
     * Hash of the recovery key.
     */
    recoveryHash: number[];
    /**
     * A copy of the presentation key encrypted with the privileged key.
     */
    presentationKeyEncrypted: number[];
    /**
     * A copy of the recovery key encrypted with the privileged key.
     */
    recoveryKeyEncrypted: number[];
    /**
     * A copy of the password key encrypted with the privileged key.
     */
    passwordKeyEncrypted: number[];
    /**
     * Describes the token's location on-chain, if it's already been published.
     */
    currentOutpoint?: OutpointString;
}
/**
 * Describes a system capable of finding and updating UMP tokens on the blockchain.
 */
export interface UMPTokenInteractor {
    /**
     * Locates the latest valid copy of a UMP token (including its outpoint)
     * based on the presentation key hash.
     *
     * @param hash The hash of the presentation key.
     * @returns The UMP token if found; otherwise, undefined.
     */
    findByPresentationKeyHash: (hash: number[]) => Promise<UMPToken | undefined>;
    /**
     * Locates the latest valid copy of a UMP token (including its outpoint)
     * based on the recovery key hash.
     *
     * @param hash The hash of the recovery key.
     * @returns The UMP token if found; otherwise, undefined.
     */
    findByRecoveryKeyHash: (hash: number[]) => Promise<UMPToken | undefined>;
    /**
     * Creates (and optionally consumes the previous version of) a UMP token on-chain.
     *
     * @param wallet            The wallet that might be used to create a new token.
     * @param adminOriginator   The domain name of the administrative originator.
     * @param token             The new UMP token to create.
     * @param oldTokenToConsume If provided, the old token that must be consumed in the same transaction.
     * @returns                 The newly created outpoint.
     */
    buildAndSend: (wallet: WalletInterface, adminOriginator: OriginatorDomainNameStringUnder250Bytes, token: UMPToken, oldTokenToConsume?: UMPToken) => Promise<OutpointString>;
}
/**
 * @class OverlayUMPTokenInteractor
 *
 * A concrete implementation of the UMPTokenInteractor interface that interacts
 * with Overlay Services and the UMP (User Management Protocol) topic. This class
 * is responsible for:
 *
 * 1) Locating UMP tokens via overlay lookups (ls_users).
 * 2) Creating and publishing new or updated UMP token outputs on-chain under
 *    the "tm_users" topic.
 * 3) Consuming (spending) an old token if provided.
 */
export declare class OverlayUMPTokenInteractor implements UMPTokenInteractor {
    /**
     * A `LookupResolver` instance used to query overlay networks.
     */
    private readonly resolver;
    /**
     * A SHIP broadcaster that can be used to publish updated UMP tokens
     * under the `tm_users` topic to overlay service peers.
     */
    private readonly broadcaster;
    /**
     * Construct a new OverlayUMPTokenInteractor.
     *
     * @param resolver     A LookupResolver instance for performing overlay queries (ls_users).
     * @param broadcaster  A SHIPBroadcaster instance for sharing new or updated tokens across the `tm_users` overlay.
     */
    constructor(resolver?: LookupResolver, broadcaster?: SHIPBroadcaster);
    /**
     * Finds a UMP token on-chain by the given presentation key hash, if it exists.
     * Uses the ls_users overlay service to perform the lookup.
     *
     * @param hash The 32-byte SHA-256 hash of the presentation key.
     * @returns A UMPToken object (including currentOutpoint) if found, otherwise undefined.
     */
    findByPresentationKeyHash(hash: number[]): Promise<UMPToken | undefined>;
    /**
     * Finds a UMP token on-chain by the given recovery key hash, if it exists.
     * Uses the ls_users overlay service to perform the lookup.
     *
     * @param hash The 32-byte SHA-256 hash of the recovery key.
     * @returns A UMPToken object (including currentOutpoint) if found, otherwise undefined.
     */
    findByRecoveryKeyHash(hash: number[]): Promise<UMPToken | undefined>;
    /**
     * Creates or updates (replaces) a UMP token on-chain. If `oldTokenToConsume` is provided,
     * it is spent in the same transaction that creates the new token output. The new token is
     * then broadcast and published under the `tm_users` topic using a SHIP broadcast, ensuring
     * overlay participants see the updated token.
     *
     * @param wallet            The wallet used to build and sign the transaction.
     * @param adminOriginator   The domain/FQDN of the administrative originator (wallet operator).
     * @param token             The new UMPToken to create on-chain.
     * @param oldTokenToConsume Optionally, an existing token to consume/spend in the same transaction.
     * @returns The outpoint of the newly created UMP token (e.g. "abcd1234...ef.0").
     */
    buildAndSend(wallet: WalletInterface, adminOriginator: OriginatorDomainNameStringUnder250Bytes, token: UMPToken, oldTokenToConsume?: UMPToken): Promise<OutpointString>;
    /**
     * Attempts to parse a LookupAnswer from the UMP lookup service. If successful,
     * extracts the token fields from the resulting transaction and constructs
     * a UMPToken object.
     *
     * @param answer The LookupAnswer returned by a query to ls_users.
     * @returns The parsed UMPToken or `undefined` if none found/decodable.
     */
    private parseLookupAnswer;
    /**
     * Finds by outpoint for unlocking / spending previous tokens.
     * @param outpoint The outpoint we are searching by
     * @returns The result so that we can use it to unlock the transaction
     */
    private findByOutpoint;
}
/**
 * Manages a "CWI-style" wallet that uses a UMP token and a
 * multi-key authentication scheme (password, presentation key, and recovery key).
 */
export declare class CWIStyleWalletManager implements WalletInterface {
    /**
     * Whether the user is currently authenticated.
     */
    authenticated: boolean;
    /**
     * The domain name of the administrative originator (wallet operator / vendor, or your own).
     */
    private adminOriginator;
    /**
     * The system that locates and publishes UMP tokens on-chain.
     */
    private UMPTokenInteractor;
    /**
     * A function called to persist the newly generated recovery key.
     * It should generally trigger a UI prompt where the user is asked to write it down.
     */
    private recoveryKeySaver;
    /**
     * Asks the user to enter their password, for a given reason.
     * The test function can be used to see if the password is correct before resolving.
     * Only resolve with the correct password or reject with an error.
     * Resolving with an incorrect password will throw an error.
     */
    private passwordRetriever;
    /**
     * An optional function that funds a new Wallet after the new-user flow, before the system proceeds.
     * Allows integration with faucets, and provides the presentation key for use in claiming faucet funds
     * that may be bound to it.
     */
    private newWalletFunder?;
    /**
     * Builds the underlying wallet once the user has been authenticated.
     */
    private walletBuilder;
    /**
     * The current mode of authentication:
     *  - 'presentation-key-and-password'
     *  - 'presentation-key-and-recovery-key'
     *  - 'recovery-key-and-password'
     */
    authenticationMode: 'presentation-key-and-password' | 'presentation-key-and-recovery-key' | 'recovery-key-and-password';
    /**
     * Indicates whether this is a new user or an existing user flow:
     *  - 'new-user'
     *  - 'existing-user'
     */
    authenticationFlow: 'new-user' | 'existing-user';
    /**
     * The current UMP token in use (representing the user's keys on-chain).
     */
    private currentUMPToken?;
    /**
     * The presentation key, temporarily retained after being provided until authenticated.
     */
    private presentationKey?;
    /**
     * The recovery key, temporarily retained after being provided until authenticated.
     */
    private recoveryKey?;
    /**
     * The user's primary key, which is used to operate the underlying wallet.
     * It is also stored within state snapshots.
     */
    private primaryKey?;
    /**
     * The underlying wallet that handles the
     * actual signing, encryption, and other wallet operations.
     */
    private underlying?;
    /**
     * Privileged key manager associated with the underlying wallet, used for
     * short-term administrative tasks (e.g. re-wrapping or rotating keys).
     */
    private underlyingPrivilegedKeyManager?;
    /**
     * Constructs a new CWIStyleWalletManager.
     *
     * @param adminOriginator   The domain name of the administrative originator.
     * @param walletBuilder     A function that can build an underlying wallet instance
     *                          from a primary key and a privileged key manager
     * @param interactor        An instance of UMPTokenInteractor capable of managing UMP tokens.
     * @param recoveryKeySaver  A function that can persist or display a newly generated recovery key.
     * @param passwordRetriever A function to request the user's password, given a reason and a test function.
     * @param newWalletFunder   An optional function called with the presentation key and a new Wallet post-construction to fund it before use.
     * @param stateSnapshot     If provided, a previously saved snapshot of the wallet's state.
     */
    constructor(adminOriginator: OriginatorDomainNameStringUnder250Bytes, walletBuilder: (primaryKey: number[], privilegedKeyManager: PrivilegedKeyManager) => Promise<WalletInterface>, interactor: UMPTokenInteractor | undefined, recoveryKeySaver: (key: number[]) => Promise<true>, passwordRetriever: (reason: string, test: (passwordCandidate: string) => boolean) => Promise<string>, newWalletFunder?: (presentationKey: number[], wallet: WalletInterface, adminOriginator: OriginatorDomainNameStringUnder250Bytes) => Promise<void>, stateSnapshot?: number[]);
    /**
     * Provides the presentation key in an authentication mode that requires it.
     * If a UMP token is found based on the key's hash, this is an existing-user flow.
     * Otherwise, it is treated as a new-user flow.
     *
     * @param key The user's presentation key (32 bytes).
     * @throws {Error} if user is already authenticated, or if the current mode does not require a presentation key.
     */
    providePresentationKey(key: number[]): Promise<void>;
    /**
     * Provides the password in an authentication mode that requires it.
     *
     * - **Existing user**:
     *   Decrypts the primary key using the provided password (and either the presentation key or recovery key, depending on the mode).
     *   Then builds the underlying wallet, marking the user as authenticated.
     *
     * - **New user**:
     *   Generates a new UMP token with fresh keys (primary, privileged, recovery). Publishes it on-chain and builds the wallet.
     *
     * @param password The user's password as a string.
     * @throws {Error} If the user is already authenticated, if the mode does not use a password, or if required keys are missing.
     */
    providePassword(password: string): Promise<void>;
    /**
     * Provides the recovery key in an authentication flow that requires it.
     *
     * @param recoveryKey The user's recovery key (32 bytes).
     * @throws {Error} if user is already authenticated, if the mode does not use a recovery key,
     *                 or if a required presentation key is missing in "presentation-key-and-recovery-key" mode.
     */
    provideRecoveryKey(recoveryKey: number[]): Promise<void>;
    /**
     * Saves the current wallet state (including the current UMP token and primary key)
     * into an encrypted snapshot. This snapshot can be stored locally and later passed
     * to `loadSnapshot` to restore the wallet state without re-authenticating manually.
     *
     * @remarks
     * Storing the snapshot provides a fully authenticated state.
     * This **must** be securely stored (e.g. system keychain or encrypted file).
     * If attackers gain access to this snapshot, they can fully control the wallet.
     *
     * @returns An array of bytes representing the encrypted snapshot.
     * @throws {Error} if no primary key or token is currently set.
     */
    saveSnapshot(): number[];
    /**
     * Loads a previously saved state snapshot (e.g. from `saveSnapshot`).
     * Upon success, the wallet becomes authenticated without needing to re-enter keys.
     *
     * @param snapshot An array of bytes that was previously produced by `saveSnapshot`.
     * @throws {Error} If the snapshot format is invalid or decryption fails.
     */
    loadSnapshot(snapshot: number[]): Promise<void>;
    /**
     * Destroys the underlying wallet, returning to a default state
     */
    destroy(): void;
    /**
     * Changes the user's password, re-wrapping the primary and privileged keys with the new password factor.
     *
     * @param newPassword The user's new password as a string.
     * @throws {Error} If the user is not authenticated, or if underlying token references are missing.
     */
    changePassword(newPassword: string): Promise<void>;
    /**
     * Retrieves the current recovery key.
     *
     * @throws {Error} If the user is not authenticated, or if underlying token references are missing.
     */
    getRecoveryKey(): Promise<number[]>;
    /**
     * Changes the user's recovery key, prompting the user to save the new key.
     *
     * @throws {Error} If the user is not authenticated, or if underlying token references are missing.
     */
    changeRecoveryKey(): Promise<void>;
    /**
     * Changes the user's presentation key.
     *
     * @param presentationKey The new presentation key (32 bytes).
     * @throws {Error} If the user is not authenticated, or if underlying token references are missing.
     */
    changePresentationKey(presentationKey: number[]): Promise<void>;
    /**
     * Internal helper to recompute a UMP token with updated authentication factors and consume the old token on-chain.
     *
     * @param passwordSalt    The PBKDF2 salt for the new password factor.
     * @param passwordKey     The PBKDF2-derived password key (32 bytes).
     * @param presentationKey The new or existing presentation key (32 bytes).
     * @param recoveryKey     The new or existing recovery key (32 bytes).
     * @param primaryKey      The user's primary key for re-wrapping.
     * @param privilegedKey   The user's privileged key for re-wrapping.
     * @throws {Error} If the user is not authenticated or if keys are unavailable.
     */
    private updateAuthFactors;
    /**
     * A helper function to XOR two equal-length byte arrays.
     *
     * @param n1 The first byte array.
     * @param n2 The second byte array.
     * @returns A new byte array which is the element-wise XOR of the two inputs.
     * @throws {Error} if the two arrays are not the same length.
     */
    private XOR;
    /**
     * A helper function to serialize a UMP token to a binary format (version=1).
     * The serialization layout is:
     *   - [1 byte version (value=1)]
     *   - For each array field in the UMP token, [varint length + bytes]
     *   - Then [varint length + outpoint string in UTF-8]
     *
     * @param token The UMP token to serialize.
     * @returns A byte array representing the serialized token.
     * @throws {Error} if the token has no currentOutpoint (required for serialization).
     */
    private serializeUMPToken;
    /**
     * A helper function to deserialize a UMP token from the format described in `serializeUMPToken`.
     *
     * @param bin The serialized byte array.
     * @returns The reconstructed UMP token.
     * @throws {Error} if the version byte is unexpected or if parsing fails.
     */
    private deserializeUMPToken;
    /**
     * Builds the underlying wallet once the user is authenticated.
     *
     * @param primaryKey      The user's primary key (32 bytes).
     * @param privilegedKey   Optionally, a privileged key (for short-term usage in account recovery).
     */
    private buildUnderlying;
    getPublicKey(args: GetPublicKeyArgs, originator?: OriginatorDomainNameStringUnder250Bytes): Promise<GetPublicKeyResult>;
    revealCounterpartyKeyLinkage(args: RevealCounterpartyKeyLinkageArgs, originator?: OriginatorDomainNameStringUnder250Bytes): Promise<RevealCounterpartyKeyLinkageResult>;
    revealSpecificKeyLinkage(args: RevealSpecificKeyLinkageArgs, originator?: OriginatorDomainNameStringUnder250Bytes): Promise<RevealSpecificKeyLinkageResult>;
    encrypt(args: WalletEncryptArgs, originator?: OriginatorDomainNameStringUnder250Bytes): Promise<WalletEncryptResult>;
    decrypt(args: WalletDecryptArgs, originator?: OriginatorDomainNameStringUnder250Bytes): Promise<WalletDecryptResult>;
    createHmac(args: CreateHmacArgs, originator?: OriginatorDomainNameStringUnder250Bytes): Promise<CreateHmacResult>;
    verifyHmac(args: VerifyHmacArgs, originator?: OriginatorDomainNameStringUnder250Bytes): Promise<VerifyHmacResult>;
    createSignature(args: CreateSignatureArgs, originator?: OriginatorDomainNameStringUnder250Bytes): Promise<CreateSignatureResult>;
    verifySignature(args: VerifySignatureArgs, originator?: OriginatorDomainNameStringUnder250Bytes): Promise<VerifySignatureResult>;
    createAction(args: CreateActionArgs, originator?: OriginatorDomainNameStringUnder250Bytes): Promise<CreateActionResult>;
    signAction(args: SignActionArgs, originator?: OriginatorDomainNameStringUnder250Bytes): Promise<SignActionResult>;
    abortAction(args: AbortActionArgs, originator?: OriginatorDomainNameStringUnder250Bytes): Promise<AbortActionResult>;
    listActions(args: ListActionsArgs, originator?: OriginatorDomainNameStringUnder250Bytes): Promise<ListActionsResult>;
    internalizeAction(args: InternalizeActionArgs, originator?: OriginatorDomainNameStringUnder250Bytes): Promise<InternalizeActionResult>;
    listOutputs(args: ListOutputsArgs, originator?: OriginatorDomainNameStringUnder250Bytes): Promise<ListOutputsResult>;
    relinquishOutput(args: RelinquishOutputArgs, originator?: OriginatorDomainNameStringUnder250Bytes): Promise<RelinquishOutputResult>;
    acquireCertificate(args: AcquireCertificateArgs, originator?: OriginatorDomainNameStringUnder250Bytes): Promise<AcquireCertificateResult>;
    listCertificates(args: ListCertificatesArgs, originator?: OriginatorDomainNameStringUnder250Bytes): Promise<ListCertificatesResult>;
    proveCertificate(args: ProveCertificateArgs, originator?: OriginatorDomainNameStringUnder250Bytes): Promise<ProveCertificateResult>;
    relinquishCertificate(args: RelinquishCertificateArgs, originator?: OriginatorDomainNameStringUnder250Bytes): Promise<RelinquishCertificateResult>;
    discoverByIdentityKey(args: DiscoverByIdentityKeyArgs, originator?: OriginatorDomainNameStringUnder250Bytes): Promise<DiscoverCertificatesResult>;
    discoverByAttributes(args: DiscoverByAttributesArgs, originator?: OriginatorDomainNameStringUnder250Bytes): Promise<DiscoverCertificatesResult>;
    isAuthenticated(_: {}, originator?: OriginatorDomainNameStringUnder250Bytes): Promise<AuthenticatedResult>;
    waitForAuthentication(_: {}, originator?: OriginatorDomainNameStringUnder250Bytes): Promise<AuthenticatedResult>;
    getHeight(_: {}, originator?: OriginatorDomainNameStringUnder250Bytes): Promise<GetHeightResult>;
    getHeaderForHeight(args: GetHeaderArgs, originator?: OriginatorDomainNameStringUnder250Bytes): Promise<GetHeaderResult>;
    getNetwork(_: {}, originator?: OriginatorDomainNameStringUnder250Bytes): Promise<GetNetworkResult>;
    getVersion(_: {}, originator?: OriginatorDomainNameStringUnder250Bytes): Promise<GetVersionResult>;
}
//# sourceMappingURL=CWIStyleWalletManager.d.ts.map