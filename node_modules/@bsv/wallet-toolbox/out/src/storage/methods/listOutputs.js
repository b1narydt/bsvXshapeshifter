"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.listOutputs = listOutputs;
const sdk_1 = require("@bsv/sdk");
const index_client_1 = require("../../index.client");
const basketToSpecOp = {
    [index_client_1.sdk.specOpWalletBalance]: {
        name: 'totalOutputsIsWalletBalance',
        useBasket: 'default',
        ignoreLimit: true,
        resultFromOutputs: async (s, auth, vargs, specOpTags, outputs) => {
            let totalOutputs = 0;
            for (const o of outputs)
                totalOutputs += o.satoshis;
            return { totalOutputs, outputs: [] };
        }
    },
    [index_client_1.sdk.specOpInvalidChange]: {
        name: 'invalidChangeOutputs',
        useBasket: 'default',
        ignoreLimit: true,
        tagsToIntercept: ['release'],
        filterOutputs: async (s, auth, vargs, specOpTags, outputs) => {
            var _a;
            const filteredOutputs = [];
            for (const o of outputs) {
                let ok = false;
                if (o.lockingScript && o.lockingScript.length > 0) {
                    const r = await s.getServices().getUtxoStatus((0, index_client_1.asString)(o.lockingScript), 'script');
                    if (r.status === 'success' && r.isUtxo && ((_a = r.details) === null || _a === void 0 ? void 0 : _a.length) > 0) {
                        if (r.details.some(d => d.txid === o.txid && d.satoshis === o.satoshis && d.index === o.vout)) {
                            ok = true;
                        }
                    }
                }
                if (!ok) {
                    filteredOutputs.push(o);
                }
            }
            if (specOpTags.indexOf('release') >= 0) {
                for (const o of filteredOutputs) {
                    await s.updateOutput(o.outputId, { spendable: false });
                }
            }
            return filteredOutputs;
        }
    },
    [index_client_1.sdk.specOpSetWalletChangeParams]: {
        name: 'setWalletChangeParams',
        tagsParamsCount: 2,
        resultFromTags: async (s, auth, vargs, specOpTags) => {
            if (specOpTags.length !== 2)
                throw new index_client_1.sdk.WERR_INVALID_PARAMETER('numberOfDesiredUTXOs and minimumDesiredUTXOValue', 'valid');
            const numberOfDesiredUTXOs = (0, index_client_1.verifyInteger)(Number(specOpTags[0]));
            const minimumDesiredUTXOValue = (0, index_client_1.verifyInteger)(Number(specOpTags[1]));
            const basket = (0, index_client_1.verifyOne)(await s.findOutputBaskets({
                partial: { userId: (0, index_client_1.verifyId)(auth.userId), name: 'default' }
            }));
            await s.updateOutputBasket(basket.basketId, {
                numberOfDesiredUTXOs,
                minimumDesiredUTXOValue
            });
            return { totalOutputs: 0, outputs: [] };
        }
    }
};
async function listOutputs(dsk, auth, vargs, originator) {
    const trx = undefined;
    const userId = (0, index_client_1.verifyId)(auth.userId);
    const limit = vargs.limit;
    const offset = vargs.offset;
    const k = dsk.toDb(trx);
    const r = {
        totalOutputs: 0,
        outputs: []
    };
    /*
          ListOutputsArgs {
              basket: BasketStringUnder300Bytes
  
              tags?: OutputTagStringUnder300Bytes[]
              tagQueryMode?: 'all' | 'any' // default any
  
              limit?: PositiveIntegerDefault10Max10000
              offset?: PositiveIntegerOrZero
          }
      */
    let specOp = undefined;
    let basketId = undefined;
    const basketsById = {};
    if (vargs.basket) {
        let b = vargs.basket;
        specOp = basketToSpecOp[b];
        b = specOp ? (specOp.useBasket ? specOp.useBasket : '') : b;
        if (b) {
            const baskets = await dsk.findOutputBaskets({
                partial: { userId, name: b },
                trx
            });
            if (baskets.length !== 1) {
                // If basket does not exist, result is no outputs.
                return r;
            }
            const basket = baskets[0];
            basketId = basket.basketId;
            basketsById[basketId] = basket;
        }
    }
    let tagIds = [];
    let tags = [...vargs.tags];
    const specOpTags = [];
    if (specOp && specOp.tagsParamsCount) {
        specOpTags.push(...tags.splice(0, Math.min(tags.length, specOp.tagsParamsCount)));
    }
    if (specOp && specOp.tagsToIntercept) {
        // Pull out tags used by current specOp
        const ts = tags;
        tags = [];
        for (const t of ts) {
            if (specOp.tagsToIntercept.length === 0 || specOp.tagsToIntercept.indexOf(t) >= 0) {
                specOpTags.push(t);
            }
            else {
                tags.push(t);
            }
        }
    }
    if (specOp && specOp.resultFromTags) {
        const r = await specOp.resultFromTags(dsk, auth, vargs, specOpTags);
        return r;
    }
    if (tags && tags.length > 0) {
        const q = k('output_tags')
            .where({
            userId: userId,
            isDeleted: false
        })
            .whereNotNull('outputTagId')
            .whereIn('tag', vargs.tags)
            .select('outputTagId');
        const r = await q;
        tagIds = r.map(r => r.outputTagId);
    }
    const isQueryModeAll = vargs.tagQueryMode === 'all';
    if (isQueryModeAll && tagIds.length < vargs.tags.length)
        return r;
    const columns = [
        'outputId',
        'transactionId',
        'basketId',
        'spendable',
        'txid',
        'vout',
        'satoshis',
        'lockingScript',
        'customInstructions',
        'outputDescription',
        'spendingDescription',
        'scriptLength',
        'scriptOffset'
    ];
    const noTags = tagIds.length === 0;
    const includeSpent = false;
    const txStatusOk = `(select status as tstatus from transactions where transactions.transactionId = outputs.transactionId) in ('completed', 'unproven', 'nosend')`;
    const txStatusOkCteq = `(select status as tstatus from transactions where transactions.transactionId = o.transactionId) in ('completed', 'unproven', 'nosend')`;
    const makeWithTagsQueries = () => {
        let cteqOptions = '';
        if (basketId)
            cteqOptions += ` AND o.basketId = ${basketId}`;
        if (!includeSpent)
            cteqOptions += ` AND o.spendable`;
        const cteq = k.raw(`
            SELECT ${columns.map(c => 'o.' + c).join(',')}, 
                    (SELECT COUNT(*) 
                    FROM output_tags_map AS m 
                    WHERE m.OutputId = o.OutputId 
                    AND m.outputTagId IN (${tagIds.join(',')}) 
                    ) AS tc
            FROM outputs AS o
            WHERE o.userId = ${userId} ${cteqOptions} AND ${txStatusOkCteq}
            `);
        const q = k.with('otc', cteq);
        q.from('otc');
        if (isQueryModeAll)
            q.where('tc', tagIds.length);
        else
            q.where('tc', '>', 0);
        const qcount = q.clone();
        q.select(columns);
        qcount.count('outputId as total');
        return { q, qcount };
    };
    const makeWithoutTagsQueries = () => {
        const where = { userId };
        if (basketId)
            where.basketId = basketId;
        if (!includeSpent)
            where.spendable = true;
        const q = k('outputs').where(where).whereRaw(txStatusOk);
        const qcount = q.clone().count('outputId as total');
        return { q, qcount };
    };
    const { q, qcount } = noTags ? makeWithoutTagsQueries() : makeWithTagsQueries();
    // Sort order when limit and offset are possible must be ascending for determinism.
    if (!specOp || !specOp.ignoreLimit)
        q.limit(limit).offset(offset);
    q.orderBy('outputId', 'asc');
    let outputs = await q;
    if (specOp) {
        if (specOp.filterOutputs)
            outputs = await specOp.filterOutputs(dsk, auth, vargs, specOpTags, outputs);
        if (specOp.resultFromOutputs) {
            const r = await specOp.resultFromOutputs(dsk, auth, vargs, specOpTags, outputs);
            return r;
        }
    }
    if (!limit || outputs.length < limit)
        r.totalOutputs = outputs.length;
    else {
        const total = (0, index_client_1.verifyOne)(await qcount)['total'];
        r.totalOutputs = Number(total);
    }
    /*
          ListOutputsArgs {
              include?: 'locking scripts' | 'entire transactions'
              includeCustomInstructions?: BooleanDefaultFalse
              includeTags?: BooleanDefaultFalse
              includeLabels?: BooleanDefaultFalse
          }
  
          ListOutputsResult {
              totalOutputs: PositiveIntegerOrZero
              BEEF?: BEEF
              outputs: Array<WalletOutput>
          }
  
          WalletOutput {
              satoshis: SatoshiValue
              spendable: boolean
              outpoint: OutpointString
  
              customInstructions?: string
              lockingScript?: HexString
              tags?: OutputTagStringUnder300Bytes[]
              labels?: LabelStringUnder300Bytes[]
          }
      */
    const labelsByTxid = {};
    const beef = new sdk_1.Beef();
    for (const o of outputs) {
        const wo = {
            satoshis: Number(o.satoshis),
            spendable: !!o.spendable,
            outpoint: `${o.txid}.${o.vout}`
        };
        r.outputs.push(wo);
        //if (vargs.includeBasket && o.basketId) {
        //    if (!basketsById[o.basketId]) {
        //        basketsById[o.basketId] = verifyTruthy(await dsk.findOutputBasketId(o.basketId!, trx))
        //    }
        //    wo.basket = basketsById[o.basketId].name
        //}
        if (vargs.includeCustomInstructions && o.customInstructions)
            wo.customInstructions = o.customInstructions;
        if (vargs.includeLabels && o.txid) {
            if (labelsByTxid[o.txid] === undefined) {
                labelsByTxid[o.txid] = (await dsk.getLabelsForTransactionId(o.transactionId, trx)).map(l => l.label);
            }
            wo.labels = labelsByTxid[o.txid];
        }
        if (vargs.includeTags) {
            wo.tags = (await dsk.getTagsForOutputId(o.outputId, trx)).map(t => t.tag);
        }
        if (vargs.includeLockingScripts) {
            await dsk.validateOutputScript(o, trx);
            if (o.lockingScript)
                wo.lockingScript = (0, index_client_1.asString)(o.lockingScript);
        }
        if (vargs.includeTransactions && !beef.findTxid(o.txid)) {
            await dsk.getValidBeefForKnownTxid(o.txid, beef, undefined, vargs.knownTxids, trx);
        }
    }
    if (vargs.includeTransactions) {
        r.BEEF = beef.toBinary();
    }
    return r;
}
//# sourceMappingURL=listOutputs.js.map