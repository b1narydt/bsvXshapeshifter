"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.WalletStorageManager = void 0;
const index_client_1 = require("../index.client");
class ManagedStorage {
    constructor(storage) {
        this.storage = storage;
        this.isStorageProvider = storage.isStorageProvider();
        this.isAvailable = false;
    }
}
/**
 * The `WalletStorageManager` class delivers authentication checking storage access to the wallet.
 *
 * If manages multiple `StorageBase` derived storage services: one actice, the rest as backups.
 *
 * Of the storage services, one is 'active' at any one time.
 * On startup, and whenever triggered by the wallet, `WalletStorageManager` runs a syncrhonization sequence:
 *
 * 1. While synchronizing, all other access to storage is blocked waiting.
 * 2. The active service is confirmed, potentially triggering a resolution process if there is disagreement.
 * 3. Changes are pushed from the active storage service to each inactive, backup service.
 *
 * Some storage services do not support multiple writers. `WalletStorageManager` manages wait-blocking write requests
 * for these services.
 */
class WalletStorageManager {
    constructor(identityKey, active, backups) {
        /**
         * All configured stores including current active, backups, and conflicting actives.
         */
        this._stores = [];
        /**
         * True if makeAvailable has been run and access to managed stores (active) is allowed
         */
        this._isAvailable = false;
        /**
         * How many read access operations are pending
         */
        this._readerCount = 0;
        /**
         * How many write access operations are pending
         */
        this._writerCount = 0;
        /**
         * if true, allow only a single writer to proceed at a time.
         * queue the blocked requests so they get executed in order when released.
         */
        this._isSingleWriter = true;
        /**
         * if true, allow no new reader or writers to proceed.
         * queue the blocked requests so they get executed in order when released.
         */
        this._syncLocked = false;
        /**
         * if true, allow no new reader or writers or sync to proceed.
         * queue the blocked requests so they get executed in order when released.
         */
        this._storageProviderLocked = false;
        const stores = [...(backups || [])];
        if (active)
            stores.unshift(active);
        this._stores = stores.map(s => new ManagedStorage(s));
        this._authId = { identityKey };
    }
    isStorageProvider() {
        return false;
    }
    isAvailable() {
        return this._isAvailable;
    }
    /**
     * The active storage is "enabled" only if its `storageIdentityKey` matches the user's currently selected `activeStorage`,
     * and only if there are no stores with conflicting `activeStorage` selections.
     *
     * A wallet may be created without including the user's currently selected active storage. This allows readonly access to their wallet data.
     *
     * In addition, if there are conflicting `activeStorage` selections among backup storage providers then the active remains disabled.
     */
    get isActiveEnabled() {
        return (this._active !== undefined &&
            this._active.settings.storageIdentityKey === this._active.user.activeStorage &&
            this._conflictingActives !== undefined &&
            this._conflictingActives.length === 0);
    }
    /**
     * @returns true if at least one WalletStorageProvider has been added.
     */
    canMakeAvailable() {
        return this._stores.length > 0;
    }
    /**
     * This async function must be called after construction and before
     * any other async function can proceed.
     *
     * Runs through `_stores` validating all properties and partitioning across `_active`, `_backups`, `_conflictingActives`.
     *
     * @throws WERR_INVALID_PARAMETER if canMakeAvailable returns false.
     *
     * @returns {TableSettings} from the active storage.
     */
    async makeAvailable() {
        var _a;
        if (this._isAvailable)
            return this._active.settings;
        this._active = undefined;
        this._backups = [];
        this._conflictingActives = [];
        if (this._stores.length < 1)
            throw new index_client_1.sdk.WERR_INVALID_PARAMETER('active', 'valid. Must add active storage provider to wallet.');
        // Initial backups. conflictingActives will be removed.
        const backups = [];
        let i = -1;
        for (const store of this._stores) {
            i++;
            if (!store.isAvailable || !store.settings || !store.user) {
                // Validate all ManagedStorage properties.
                store.settings = await store.storage.makeAvailable();
                const r = await store.storage.findOrInsertUser(this._authId.identityKey);
                store.user = r.user;
                store.isAvailable = true;
            }
            if (!this._active)
                // _stores[0] becomes the default active store. It may be replaced if it is not the user's "enabled" activeStorage and that store is found among the remainder (backups).
                this._active = store;
            else {
                const ua = store.user.activeStorage;
                const si = store.settings.storageIdentityKey;
                if (ua === si && !this.isActiveEnabled) {
                    // This store's user record selects it as an enabled active storage...
                    // swap the current not-enabled active for this storeage.
                    backups.push(this._active);
                    this._active = store;
                }
                else {
                    // This store is a backup: Its user record selects some other storage as active.
                    backups.push(store);
                }
            }
        }
        // Review backups, partition out conflicting actives.
        const si = (_a = this._active.settings) === null || _a === void 0 ? void 0 : _a.storageIdentityKey;
        for (const store of backups) {
            if (store.user.activeStorage !== si)
                this._conflictingActives.push(store);
            else
                this._backups.push(store);
        }
        this._isAvailable = true;
        this._authId.userId = this._active.user.userId;
        this._authId.isActive = this.isActiveEnabled;
        return this._active.settings;
    }
    verifyActive() {
        if (!this._active || !this._isAvailable)
            throw new index_client_1.sdk.WERR_INVALID_OPERATION('An active WalletStorageProvider must be added to this WalletStorageManager and makeAvailable must be called.');
        return this._active;
    }
    async getAuth(mustBeActive) {
        if (!this.isAvailable())
            await this.makeAvailable();
        if (mustBeActive && !this._authId.isActive)
            throw new index_client_1.sdk.WERR_NOT_ACTIVE();
        return this._authId;
    }
    async getUserId() {
        return (await this.getAuth()).userId;
    }
    getActive() {
        return this.verifyActive().storage;
    }
    getActiveSettings() {
        return this.verifyActive().settings;
    }
    getActiveUser() {
        return this.verifyActive().user;
    }
    getActiveStore() {
        return this.verifyActive().settings.storageIdentityKey;
    }
    getActiveStoreName() {
        return this.verifyActive().settings.storageName;
    }
    getBackupStores() {
        this.verifyActive();
        return this._backups.map(b => b.settings.storageIdentityKey);
    }
    getConflictingStores() {
        this.verifyActive();
        return this._conflictingActives.map(b => b.settings.storageIdentityKey);
    }
    getAllStores() {
        this.verifyActive();
        return this._stores.map(b => b.settings.storageIdentityKey);
    }
    async getActiveForWriter() {
        if (!this.isAvailable())
            await this.makeAvailable();
        while (this._storageProviderLocked ||
            this._syncLocked ||
            (this._isSingleWriter && this._writerCount > 0) ||
            this._readerCount > 0) {
            await (0, index_client_1.wait)(100);
        }
        this._writerCount++;
        return this.getActive();
    }
    async getActiveForReader() {
        if (!this.isAvailable())
            await this.makeAvailable();
        while (this._storageProviderLocked || this._syncLocked || (this._isSingleWriter && this._writerCount > 0)) {
            await (0, index_client_1.wait)(100);
        }
        this._readerCount++;
        return this.getActive();
    }
    async getActiveForSync() {
        if (!this.isAvailable())
            await this.makeAvailable();
        // Wait for a current sync task to complete...
        while (this._syncLocked) {
            await (0, index_client_1.wait)(100);
        }
        // Set syncLocked which prevents any new storageProvider, readers or writers...
        this._syncLocked = true;
        // Wait for any current storageProvider, readers and writers to complete
        while (this._storageProviderLocked || this._readerCount > 0 || this._writerCount > 0) {
            await (0, index_client_1.wait)(100);
        }
        // Allow the sync to proceed on the active store.
        return this.getActive();
    }
    async getActiveForStorageProvider() {
        if (!this.isAvailable())
            await this.makeAvailable();
        // Wait for a current storageProvider call to complete...
        while (this._storageProviderLocked) {
            await (0, index_client_1.wait)(100);
        }
        // Set storageProviderLocked which prevents any new sync, readers or writers...
        this._storageProviderLocked = true;
        // Wait for any current sync, readers and writers to complete
        while (this._syncLocked || this._readerCount > 0 || this._writerCount > 0) {
            await (0, index_client_1.wait)(100);
        }
        // We can finally confirm that active storage is still able to support `StorageProvider`
        if (!this.getActive().isStorageProvider())
            throw new index_client_1.sdk.WERR_INVALID_OPERATION('Active "WalletStorageProvider" does not support "StorageProvider" interface.');
        // Allow the sync to proceed on the active store.
        return this.getActive();
    }
    async runAsWriter(writer) {
        try {
            const active = await this.getActiveForWriter();
            const r = await writer(active);
            return r;
        }
        finally {
            this._writerCount--;
        }
    }
    async runAsReader(reader) {
        try {
            const active = await this.getActiveForReader();
            const r = await reader(active);
            return r;
        }
        finally {
            this._readerCount--;
        }
    }
    /**
     *
     * @param sync the function to run with sync access lock
     * @param activeSync from chained sync functions, active storage already held under sync access lock.
     * @returns
     */
    async runAsSync(sync, activeSync) {
        try {
            const active = activeSync || (await this.getActiveForSync());
            const r = await sync(active);
            return r;
        }
        finally {
            if (!activeSync)
                this._syncLocked = false;
        }
    }
    async runAsStorageProvider(sync) {
        try {
            const active = await this.getActiveForStorageProvider();
            const r = await sync(active);
            return r;
        }
        finally {
            this._storageProviderLocked = false;
        }
    }
    /**
     *
     * @returns true if the active `WalletStorageProvider` also implements `StorageProvider`
     */
    isActiveStorageProvider() {
        return this.getActive().isStorageProvider();
    }
    async addWalletStorageProvider(provider) {
        await provider.makeAvailable();
        if (this._services)
            provider.setServices(this._services);
        this._stores.push(new ManagedStorage(provider));
        this._isAvailable = false;
        await this.makeAvailable();
    }
    setServices(v) {
        this._services = v;
        for (const store of this._stores)
            store.storage.setServices(v);
    }
    getServices() {
        if (!this._services)
            throw new index_client_1.sdk.WERR_INVALID_OPERATION('Must setServices first.');
        return this._services;
    }
    getSettings() {
        return this.getActive().getSettings();
    }
    async migrate(storageName, storageIdentityKey) {
        return await this.runAsWriter(async (writer) => {
            return writer.migrate(storageName, storageIdentityKey);
        });
    }
    async destroy() {
        if (this._stores.length < 1)
            return;
        return await this.runAsWriter(async (writer) => {
            for (const store of this._stores)
                await store.storage.destroy();
        });
    }
    async findOrInsertUser(identityKey) {
        const auth = await this.getAuth();
        if (identityKey != auth.identityKey)
            throw new index_client_1.sdk.WERR_UNAUTHORIZED();
        return await this.runAsWriter(async (writer) => {
            const r = await writer.findOrInsertUser(identityKey);
            if (auth.userId && auth.userId !== r.user.userId)
                throw new index_client_1.sdk.WERR_INTERNAL('userId may not change for given identityKey');
            this._authId.userId = r.user.userId;
            return r;
        });
    }
    async abortAction(args) {
        index_client_1.sdk.validateAbortActionArgs(args);
        return await this.runAsWriter(async (writer) => {
            const auth = await this.getAuth(true);
            return await writer.abortAction(auth, args);
        });
    }
    async createAction(vargs) {
        return await this.runAsWriter(async (writer) => {
            const auth = await this.getAuth(true);
            return await writer.createAction(auth, vargs);
        });
    }
    async internalizeAction(args) {
        index_client_1.sdk.validateInternalizeActionArgs(args);
        return await this.runAsWriter(async (writer) => {
            const auth = await this.getAuth(true);
            return await writer.internalizeAction(auth, args);
        });
    }
    async relinquishCertificate(args) {
        index_client_1.sdk.validateRelinquishCertificateArgs(args);
        return await this.runAsWriter(async (writer) => {
            const auth = await this.getAuth(true);
            return await writer.relinquishCertificate(auth, args);
        });
    }
    async relinquishOutput(args) {
        index_client_1.sdk.validateRelinquishOutputArgs(args);
        return await this.runAsWriter(async (writer) => {
            const auth = await this.getAuth(true);
            return await writer.relinquishOutput(auth, args);
        });
    }
    async processAction(args) {
        return await this.runAsWriter(async (writer) => {
            const auth = await this.getAuth(true);
            return await writer.processAction(auth, args);
        });
    }
    async insertCertificate(certificate) {
        return await this.runAsWriter(async (writer) => {
            const auth = await this.getAuth(true);
            return await writer.insertCertificateAuth(auth, certificate);
        });
    }
    async listActions(vargs) {
        const auth = await this.getAuth();
        return await this.runAsReader(async (reader) => {
            return await reader.listActions(auth, vargs);
        });
    }
    async listCertificates(args) {
        const auth = await this.getAuth();
        return await this.runAsReader(async (reader) => {
            return await reader.listCertificates(auth, args);
        });
    }
    async listOutputs(vargs) {
        const auth = await this.getAuth();
        return await this.runAsReader(async (reader) => {
            return await reader.listOutputs(auth, vargs);
        });
    }
    async findCertificates(args) {
        const auth = await this.getAuth();
        return await this.runAsReader(async (reader) => {
            return await reader.findCertificatesAuth(auth, args);
        });
    }
    async findOutputBaskets(args) {
        const auth = await this.getAuth();
        return await this.runAsReader(async (reader) => {
            return await reader.findOutputBasketsAuth(auth, args);
        });
    }
    async findOutputs(args) {
        const auth = await this.getAuth();
        return await this.runAsReader(async (reader) => {
            return await reader.findOutputsAuth(auth, args);
        });
    }
    async findProvenTxReqs(args) {
        return await this.runAsReader(async (reader) => {
            return await reader.findProvenTxReqs(args);
        });
    }
    async syncFromReader(identityKey, reader, activeSync, log = '') {
        const auth = await this.getAuth();
        if (identityKey !== auth.identityKey)
            throw new index_client_1.sdk.WERR_UNAUTHORIZED();
        const readerSettings = await reader.makeAvailable();
        let inserts = 0, updates = 0;
        log = await this.runAsSync(async (sync) => {
            const writer = sync;
            const writerSettings = this.getSettings();
            log += `syncFromReader from ${readerSettings.storageName} to ${writerSettings.storageName}\n`;
            let i = -1;
            for (;;) {
                i++;
                const ss = await index_client_1.EntitySyncState.fromStorage(writer, identityKey, readerSettings);
                const args = ss.makeRequestSyncChunkArgs(identityKey, writerSettings.storageIdentityKey);
                const chunk = await reader.getSyncChunk(args);
                if (chunk.user) {
                    // Merging state from a reader cannot update activeStorage
                    chunk.user.activeStorage = this._active.user.activeStorage;
                }
                const r = await writer.processSyncChunk(args, chunk);
                inserts += r.inserts;
                updates += r.updates;
                log += `chunk ${i} inserted ${r.inserts} updated ${r.updates} ${r.maxUpdated_at}\n`;
                if (r.done)
                    break;
            }
            log += `syncFromReader complete: ${inserts} inserts, ${updates} updates\n`;
            return log;
        }, activeSync);
        return { inserts, updates, log };
    }
    async syncToWriter(auth, writer, activeSync, log = '') {
        const identityKey = auth.identityKey;
        const writerSettings = await writer.makeAvailable();
        let inserts = 0, updates = 0;
        log = await this.runAsSync(async (sync) => {
            const reader = sync;
            const readerSettings = reader.getSettings();
            log += `syncToWriter from ${readerSettings.storageName} to ${writerSettings.storageName}\n`;
            let i = -1;
            for (;;) {
                i++;
                const ss = await index_client_1.EntitySyncState.fromStorage(writer, identityKey, readerSettings);
                const args = ss.makeRequestSyncChunkArgs(identityKey, writerSettings.storageIdentityKey);
                const chunk = await reader.getSyncChunk(args);
                log += index_client_1.EntitySyncState.syncChunkSummary(chunk);
                const r = await writer.processSyncChunk(args, chunk);
                inserts += r.inserts;
                updates += r.updates;
                log += `chunk ${i} inserted ${r.inserts} updated ${r.updates} ${r.maxUpdated_at}\n`;
                if (r.done)
                    break;
            }
            log += `syncToWriter complete: ${inserts} inserts, ${updates} updates\n`;
            return log;
        }, activeSync);
        return { inserts, updates, log };
    }
    async updateBackups(activeSync) {
        const auth = await this.getAuth(true);
        return await this.runAsSync(async (sync) => {
            let log = `BACKUP CURRENT ACTIVE TO ${this._backups.length} STORES\n`;
            for (const backup of this._backups) {
                const stwr = await this.syncToWriter(auth, backup.storage, sync);
                log += stwr.log;
            }
            return log;
        }, activeSync);
    }
    /**
     * Updates backups and switches to new active storage provider from among current backup providers.
     *
     * Also resolves conflicting actives.
     *
     * @param storageIdentityKey of current backup storage provider that is to become the new active provider.
     */
    async setActive(storageIdentityKey) {
        if (!this.isAvailable())
            await this.makeAvailable();
        // Confirm a valid storageIdentityKey: must match one of the _stores.
        const newActiveIndex = this._stores.findIndex(s => s.settings.storageIdentityKey === storageIdentityKey);
        if (newActiveIndex < 0)
            throw new index_client_1.sdk.WERR_INVALID_PARAMETER('storageIdentityKey', `registered with this "WalletStorageManager". ${storageIdentityKey} does not match any managed store.`);
        const identityKey = (await this.getAuth()).identityKey;
        const newActive = this._stores[newActiveIndex];
        let log = `setActive to ${newActive.settings.storageName}`;
        if (storageIdentityKey === this.getActiveStore() && this.isActiveEnabled)
            /** Setting the current active as the new active is a permitted no-op. */
            return log + ` unchanged\n`;
        log += '\n';
        log += await this.runAsSync(async (sync) => {
            let log = '';
            if (this._conflictingActives.length > 0) {
                // Merge state from conflicting actives into `newActive`.
                // Handle case where new active is current active to resolve conflicts.
                // And where new active is one of the current conflict actives.
                this._conflictingActives.push(this._active);
                // Remove the new active from conflicting actives and
                // set new active as the conflicting active that matches the target `storageIdentityKey`
                this._conflictingActives = this._conflictingActives.filter(ca => {
                    const isNewActive = ca.settings.storageIdentityKey === storageIdentityKey;
                    return !isNewActive;
                });
                // Merge state from conflicting actives into `newActive`.
                for (const conflict of this._conflictingActives) {
                    log += 'MERGING STATE FROM CONFLICTING ACTIVES:\n';
                    const sfr = await this.syncToWriter({ identityKey, userId: newActive.user.userId, isActive: false }, newActive.storage, conflict.storage);
                    log += sfr.log;
                }
                log += 'PROPAGATE MERGED ACTIVE STATE TO NON-ACTIVES\n';
            }
            else {
                log += 'BACKUP CURRENT ACTIVE STATE THEN SET NEW ACTIVE\n';
            }
            // If there were conflicting actives,
            // Push state merged from all merged actives into newActive to all stores other than the now single active.
            // Otherwise,
            // Push state from current active to all other stores.
            const backupSource = this._conflictingActives.length > 0 ? newActive : this._active;
            // Update the backupSource's user record with the new activeStorage
            // which will propagate to all other stores in the following backup loop.
            await backupSource.storage.setActive({ identityKey, userId: backupSource.user.userId }, storageIdentityKey);
            for (const store of this._stores) {
                // Update cached user.activeStorage of all stores
                store.user.activeStorage = storageIdentityKey;
                if (store.settings.storageIdentityKey !== backupSource.settings.storageIdentityKey) {
                    // If this store is not the backupSource store push state from backupSource to this store.
                    const stwr = await this.syncToWriter({ identityKey, userId: store.user.userId, isActive: false }, store.storage, backupSource.storage);
                    log += stwr.log;
                }
            }
            this._isAvailable = false;
            await this.makeAvailable();
            return log;
        });
        return log;
    }
}
exports.WalletStorageManager = WalletStorageManager;
//# sourceMappingURL=WalletStorageManager.js.map