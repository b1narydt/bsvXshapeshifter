import { BEEF, CreateActionOptions, CreateActionOutput, CreateActionResult, KeyDeriver, LockingScript, PrivateKey, PublicKey, WalletInterface } from '@bsv/sdk';
import { Monitor, sdk, Services, Wallet, WalletStorageManager } from './index.client';
import { Knex } from 'knex';
import { StorageKnex } from './index.all';
/**
 * The 'Setup` class provides static setup functions to construct BRC-100 compatible
 * wallets in a variety of configurations.
 *
 * It serves as a starting point for experimentation and customization.
 */
export declare abstract class Setup {
    /**
     * @param chain
     * @returns true if .env is not valid for chain
     */
    static noEnv(chain: sdk.Chain): boolean;
    /**
     * Creates content for .env file with some private keys, identity keys, sample API keys, and sample MySQL connection string.
     *
     * Two new, random private keys are generated each time, with their associated public identity keys.
     *
     * Loading secrets from a .env file is intended only for experimentation and getting started.
     * Private keys should never be included directly in your source code.
     *
     * @publicbody
     */
    static makeEnv(): string;
    /**
     * Reads a .env file of the format created by `makeEnv`.
     *
     * Returns values for designated `chain`.
     *
     * Access private keys through the `devKeys` object: `devKeys[identityKey]`
     *
     * @param chain Which chain to use: 'test' or 'main'
     * @returns {SetupEnv} with configuration environment secrets used by `Setup` functions.
     *
     * @publicbody
     */
    static getEnv(chain: sdk.Chain): SetupEnv;
    /**
     * Create a `Wallet`. Storage can optionally be provided or configured later.
     *
     * The following components are configured: KeyDeriver, WalletStorageManager, WalletService, WalletStorage.
     * Optionally, PrivilegedKeyManager is also configured.
     *
     * @publicbody
     */
    static createWallet(args: SetupWalletArgs): Promise<SetupWallet>;
    /**
     * Setup a new `Wallet` without requiring a .env file.
     *
     * @param args.chain - 'main' or 'test'
     * @param args.rootKeyHex  - Root private key for wallet's key deriver.
     * @param args.storageUrl - Optional. `StorageClient` and `chain` compatible endpoint URL.
     * @param args.privilegedKeyGetter - Optional. Method that will return the privileged `PrivateKey`, on demand.
     */
    static createWalletClientNoEnv(args: {
        chain: sdk.Chain;
        rootKeyHex: string;
        storageUrl?: string;
        privilegedKeyGetter?: () => Promise<PrivateKey>;
    }): Promise<Wallet>;
    /**
     * @publicbody
     */
    static createWalletClient(args: SetupWalletClientArgs): Promise<SetupWalletClient>;
    /**
     * @publicbody
     */
    static getKeyPair(priv?: string | PrivateKey): KeyPairAddress;
    /**
     * @publicbody
     */
    static getLockP2PKH(address: string): LockingScript;
    /**
     * @publicbody
     */
    static getUnlockP2PKH(priv: PrivateKey, satoshis: number): sdk.ScriptTemplateUnlock;
    /**
     * @publicbody
     */
    static createP2PKHOutputs(outputs: {
        address: string;
        satoshis: number;
        outputDescription?: string;
        basket?: string;
        tags?: string[];
    }[]): CreateActionOutput[];
    /**
     * @publicbody
     */
    static createP2PKHOutputsAction(wallet: WalletInterface, outputs: {
        address: string;
        satoshis: number;
        outputDescription?: string;
        basket?: string;
        tags?: string[];
    }[], options?: CreateActionOptions): Promise<{
        cr: CreateActionResult;
        outpoints: string[] | undefined;
    }>;
    /**
     * @publicbody
     */
    static fundWalletFromP2PKHOutpoints(wallet: WalletInterface, outpoints: string[], p2pkhKey: KeyPairAddress, inputBEEF?: BEEF): Promise<void>;
    /**
     * Adds `Knex` based storage to a `Wallet` configured by `Setup.createWalletOnly`
     *
     * @param args.knex `Knex` object configured for either MySQL or SQLite database access.
     * Schema will be created and migrated as needed.
     * For MySQL, a schema corresponding to databaseName must exist with full access permissions.
     * @param args.databaseName Name for this storage. For MySQL, the schema name within the MySQL instance.
     * @param args.chain Which chain this wallet is on: 'main' or 'test'. Defaults to 'test'.
     * @param args.rootKeyHex
     *
     * @publicbody
     */
    static createWalletKnex(args: SetupWalletKnexArgs): Promise<SetupWalletKnex>;
    /**
     * @returns {StorageKnex} - `Knex` based storage provider for a wallet. May be used for either active storage or backup storage.
     */
    static createStorageKnex(args: SetupWalletKnexArgs): Promise<StorageKnex>;
    /**
     * @publicbody
     */
    static createSQLiteKnex(filename: string): Knex;
    /**
     * @publicbody
     */
    static createMySQLKnex(connection: string, database?: string): Knex;
    /**
     * @publicbody
     */
    static createWalletMySQL(args: SetupWalletMySQLArgs): Promise<SetupWalletKnex>;
    /**
     * @publicbody
     */
    static createWalletSQLite(args: SetupWalletSQLiteArgs): Promise<SetupWalletKnex>;
}
/**
 * Arguments used by `createWallet` to construct a `SetupWallet`.
 *
 * Extension `SetupWalletClientArgs` used by `createWalletClient` to construct a `SetupWalletClient`.
 *
 * Extension `SetupWalletKnexArgs` used by `createWalletKnex` to construct a `SetupWalletKnex`.
 *
 * Extension `SetupWalletMySQLArgs` used by `createWalletMySQL` to construct a `SetupWalletKnex`.
 *
 * Extension `SetupWalletSQLiteArgs` used by `createWalletSQLite` to construct a `SetupWalletKnex`.
 */
export interface SetupWalletArgs {
    /**
     * Configuration "secrets" typically obtained by `Setup.makeEnv` and `Setup.getEnv` functions.
     */
    env: SetupEnv;
    /**
     * Optional. The non-privileged private key used to initialize the `KeyDeriver` and determine the `identityKey`.
     * Defaults to `env.devKeys[env.identityKey]
     */
    rootKeyHex?: string;
    /**
     * Optional. The privileged private key getter used to initialize the `PrivilegedKeyManager`.
     * Defaults to undefined.
     */
    privilegedKeyGetter?: () => Promise<PrivateKey>;
    /**
     * Optional. Active wallet storage. Can be added later.
     */
    active?: sdk.WalletStorageProvider;
    /**
     * Optional. One or more storage providers managed as backup destinations. Can be added later.
     */
    backups?: sdk.WalletStorageProvider[];
}
/**
 *
 */
export interface SetupWalletKnexArgs extends SetupWalletArgs {
    knex: Knex<any, any[]>;
    databaseName: string;
}
/**
 *
 */
export interface SetupWalletMySQLArgs extends SetupWalletArgs {
    databaseName: string;
}
/**
 *
 */
export interface SetupWalletSQLiteArgs extends SetupWalletArgs {
    filePath: string;
    databaseName: string;
}
/**
 *
 */
export interface SetupWalletKnex extends SetupWallet {
    activeStorage: StorageKnex;
    userId: number;
    rootKey: PrivateKey;
    identityKey: string;
    keyDeriver: KeyDeriver;
    chain: sdk.Chain;
    storage: WalletStorageManager;
    services: Services;
    monitor: Monitor;
    wallet: Wallet;
}
/**
 * A private key and associated public key and address.
 */
export interface KeyPairAddress {
    privateKey: PrivateKey;
    publicKey: PublicKey;
    address: string;
}
/**
 * `SetupEnv` provides a starting point for managing secrets that
 * must not appear in source code.
 *
 * The `makeEnv` and `getEnv` functions of the `Setup` and `SetupClient` classes
 * provide an easy way to create and import these secrets and related properties.
 */
export interface SetupEnv {
    /**
     * The chan being accessed: 'main' for mainnet, 'test' for 'testnet'.
     */
    chain: sdk.Chain;
    /**
     * The user's primary identity key (public key).
     */
    identityKey: string;
    /**
     * A secondary identity key (public key), used to test exchanges with other users.
     */
    identityKey2: string;
    /**
     * Filepath to sqlite file to be used for identityKey wallet.
     */
    filePath: string | undefined;
    /**
     * A vaild TAAL API key for use by `Services`
     */
    taalApiKey: string;
    /**
     * A map of public keys (identity keys, hex strings) to private keys (hex strings).
     */
    devKeys: Record<string, string>;
    /**
     * A MySQL connection string including user and password properties.
     * Must be valid to make use of MySQL `Setup` class support.
     */
    mySQLConnection: string;
}
/**
 * When creating a BRC-100 compatible `Wallet`, many components come into play.
 *
 * All of the `createWallet` functions in the `Setup` and `SetupClient` classes return
 * an object with direct access to each component to facilitate experimentation, testing
 * and customization.
 */
export interface SetupWallet {
    /**
     * The rootKey of the `KeyDeriver`. The private key from which other keys are derived.
     */
    rootKey: PrivateKey;
    /**
     * The pubilc key associated with the `rootKey` which also serves as the wallet's identity.
     */
    identityKey: string;
    /**
     * The `KeyDeriver` component used by the wallet for key derivation and cryptographic functions.
     */
    keyDeriver: KeyDeriver;
    /**
     * The chain ('main' or 'test') which the wallet accesses.
     */
    chain: sdk.Chain;
    /**
     * The `WalletStorageManager` that manages all the configured storage providers (active and backups)
     * accessed by the wallet.
     */
    storage: WalletStorageManager;
    /**
     * The network `Services` component which provides the wallet with access to external services hosted
     * on the public network.
     */
    services: Services;
    /**
     * The background task `Monitor` component available to the wallet to offload tasks
     * that speed up wallet operations and maintain data integrity.
     */
    monitor: Monitor;
    /**
     * The actual BRC-100 `Wallet` to which all the other properties and components contribute.
     *
     * Note that internally, the wallet is itself linked to all these properties and components.
     * They are included in this interface to facilitate access after wallet construction for
     * experimentation, testing and customization. Any changes made to the configuration of these
     * components after construction may disrupt the normal operation of the wallet.
     */
    wallet: Wallet;
}
/**
 * Extension `SetupWalletClientArgs` of `SetupWalletArgs` is used by `createWalletClient`
 * to construct a `SetupWalletClient`.
 */
export interface SetupWalletClientArgs extends SetupWalletArgs {
    /**
     * The endpoint URL of a service hosting the `StorageServer` JSON-RPC service to
     * which a `StorageClient` instance should connect to function as
     * the active storage provider of the newly created wallet.
     */
    endpointUrl?: string;
}
/**
 * Extension `SetupWalletClient` of `SetupWallet` is returned by `createWalletClient`
 */
export interface SetupWalletClient extends SetupWallet {
    /**
     * The endpoint URL of the service hosting the `StorageServer` JSON-RPC service to
     * which a `StorageClient` instance is connected to function as
     * the active storage provider of the wallet.
     */
    endpointUrl: string;
}
//# sourceMappingURL=Setup.d.ts.map