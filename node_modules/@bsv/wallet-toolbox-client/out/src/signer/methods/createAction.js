"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createAction = createAction;
exports.makeChangeLock = makeChangeLock;
exports.completeSignedTransaction = completeSignedTransaction;
exports.processAction = processAction;
const sdk_1 = require("@bsv/sdk");
const sdk_2 = require("@bsv/sdk");
const index_client_1 = require("../../index.client");
const buildSignableTransaction_1 = require("./buildSignableTransaction");
async function createAction(wallet, auth, vargs) {
    var _a;
    const r = {};
    let prior = undefined;
    if (vargs.isNewTx) {
        prior = await createNewTx(wallet, vargs);
        if (vargs.isSignAction) {
            return makeSignableTransactionResult(prior, wallet, vargs);
        }
        prior.tx = await completeSignedTransaction(prior, {}, wallet);
        r.txid = prior.tx.id('hex');
        r.noSendChange = (_a = prior.dcr.noSendChangeOutputVouts) === null || _a === void 0 ? void 0 : _a.map(vout => `${r.txid}.${vout}`);
        if (!vargs.options.returnTXIDOnly)
            r.tx = (0, index_client_1.makeAtomicBeef)(prior.tx, prior.dcr.inputBeef);
    }
    r.sendWithResults = await processAction(prior, wallet, auth, vargs);
    return r;
}
async function createNewTx(wallet, args) {
    const storageArgs = removeUnlockScripts(args);
    const dcr = await wallet.storage.createAction(storageArgs);
    const reference = dcr.reference;
    const { tx, amount, pdi } = (0, buildSignableTransaction_1.buildSignableTransaction)(dcr, args, wallet);
    const prior = { reference, dcr, args, amount, tx, pdi };
    return prior;
}
function makeSignableTransactionResult(prior, wallet, args) {
    var _a;
    if (!prior.dcr.inputBeef)
        throw new index_client_1.sdk.WERR_INTERNAL('prior.dcr.inputBeef must be valid');
    const txid = prior.tx.id('hex');
    const r = {
        noSendChange: args.isNoSend ? (_a = prior.dcr.noSendChangeOutputVouts) === null || _a === void 0 ? void 0 : _a.map(vout => `${txid}.${vout}`) : undefined,
        signableTransaction: {
            reference: prior.dcr.reference,
            tx: makeSignableTransactionBeef(prior.tx, prior.dcr.inputBeef)
        }
    };
    wallet.pendingSignActions[r.signableTransaction.reference] = prior;
    return r;
}
function makeSignableTransactionBeef(tx, inputBEEF) {
    // This is a special case beef for transaction signing.
    // We only need the transaction being signed, and for each input, the raw source transaction.
    const beef = new sdk_1.Beef();
    for (const input of tx.inputs) {
        if (!input.sourceTransaction)
            throw new index_client_1.sdk.WERR_INTERNAL('Every signableTransaction input must have a sourceTransaction');
        beef.mergeRawTx(input.sourceTransaction.toBinary());
    }
    beef.mergeRawTx(tx.toBinary());
    return beef.toBinaryAtomic(tx.id('hex'));
}
/**
 * Derive a change output locking script
 */
function makeChangeLock(out, dctr, args, changeKeys, wallet) {
    const derivationPrefix = dctr.derivationPrefix;
    const derivationSuffix = (0, index_client_1.verifyTruthy)(out.derivationSuffix);
    const sabppp = new index_client_1.ScriptTemplateBRC29({
        derivationPrefix,
        derivationSuffix,
        keyDeriver: wallet.keyDeriver
    });
    const lockingScript = sabppp.lock(changeKeys.privateKey, changeKeys.publicKey);
    return lockingScript;
}
async function completeSignedTransaction(prior, spends, wallet) {
    /////////////////////
    // Insert the user provided unlocking scripts from "spends" arg
    /////////////////////
    for (const [key, spend] of Object.entries(spends)) {
        const vin = Number(key);
        const createInput = prior.args.inputs[vin];
        const input = prior.tx.inputs[vin];
        if (!createInput || !input || createInput.unlockingScript || !Number.isInteger(createInput.unlockingScriptLength))
            throw new index_client_1.sdk.WERR_INVALID_PARAMETER('args', `spend does not correspond to prior input with valid unlockingScriptLength.`);
        if (spend.unlockingScript.length / 2 > createInput.unlockingScriptLength)
            throw new index_client_1.sdk.WERR_INVALID_PARAMETER('args', `spend unlockingScript length ${spend.unlockingScript.length} exceeds expected length ${createInput.unlockingScriptLength}`);
        input.unlockingScript = (0, index_client_1.asBsvSdkScript)(spend.unlockingScript);
        if (spend.sequenceNumber !== undefined)
            input.sequence = spend.sequenceNumber;
    }
    const results = {
        sdk: {}
    };
    /////////////////////
    // Insert SABPPP unlock templates for storage signed inputs
    /////////////////////
    for (const pdi of prior.pdi) {
        const sabppp = new index_client_1.ScriptTemplateBRC29({
            derivationPrefix: pdi.derivationPrefix,
            derivationSuffix: pdi.derivationSuffix,
            keyDeriver: wallet.keyDeriver
        });
        const keys = wallet.getClientChangeKeyPair();
        const lockerPrivKey = keys.privateKey;
        const unlockerPubKey = pdi.unlockerPubKey || keys.publicKey;
        const sourceSatoshis = pdi.sourceSatoshis;
        const lockingScript = (0, index_client_1.asBsvSdkScript)(pdi.lockingScript);
        const unlockTemplate = sabppp.unlock(lockerPrivKey, unlockerPubKey, sourceSatoshis, lockingScript);
        const input = prior.tx.inputs[pdi.vin];
        input.unlockingScriptTemplate = unlockTemplate;
    }
    /////////////////////
    // Sign storage signed inputs making transaction fully valid.
    /////////////////////
    await prior.tx.sign();
    return prior.tx;
}
function removeUnlockScripts(args) {
    let storageArgs = args;
    if (!storageArgs.inputs.every(i => i.unlockingScript === undefined)) {
        // Never send unlocking scripts to storage, all it needs is the script length.
        storageArgs = { ...args, inputs: [] };
        for (const i of args.inputs) {
            const di = {
                ...i,
                unlockingScriptLength: i.unlockingScript !== undefined ? i.unlockingScript.length : i.unlockingScriptLength
            };
            delete di.unlockingScript;
            storageArgs.inputs.push(di);
        }
    }
    return storageArgs;
}
async function processAction(prior, wallet, auth, vargs) {
    const args = {
        isNewTx: vargs.isNewTx,
        isSendWith: vargs.isSendWith,
        isNoSend: vargs.isNoSend,
        isDelayed: vargs.isDelayed,
        reference: prior ? prior.reference : undefined,
        txid: prior ? prior.tx.id('hex') : undefined,
        rawTx: prior ? prior.tx.toBinary() : undefined,
        sendWith: vargs.isSendWith ? vargs.options.sendWith : []
    };
    const r = await wallet.storage.processAction(args);
    return r.sendWithResults;
}
function makeDummyTransactionForOutputSatoshis(vout, satoshis) {
    const tx = new sdk_2.Transaction();
    for (let i = 0; i < vout; i++)
        tx.addOutput({ lockingScript: new sdk_2.Script(), satoshis: 0 });
    tx.addOutput({ lockingScript: new sdk_2.Script(), satoshis });
    return tx;
}
//# sourceMappingURL=createAction.js.map